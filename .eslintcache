[{"/Users/jani/Code/Web/dxpaint/src/index.tsx":"1","/Users/jani/Code/Web/dxpaint/src/components/App.tsx":"2","/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx":"3","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx":"4","/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx":"5","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx":"6","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts":"7","/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts":"8","/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts":"9","/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts":"10","/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx":"11","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx":"12","/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx":"13","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts":"14","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts":"15","/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts":"16","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts":"17","/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts":"18","/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts":"19","/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts":"20","/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx":"21","/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx":"22","/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx":"23","/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx":"24","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx":"25","/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx":"26","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts":"27","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx":"28","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx":"29","/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx":"30","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts":"31","/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts":"32","/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts":"33","/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts":"34","/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx":"35","/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx":"36","/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx":"37","/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx":"38","/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx":"39","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx":"40","/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx":"41","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx":"42","/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx":"43","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx":"44","/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx":"45","/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx":"46","/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx":"47","/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx":"48","/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts":"49","/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts":"50","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts":"51","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx":"52","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx":"53","/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts":"54","/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts":"55","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx":"56","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx":"57","/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx":"58","/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx":"59","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts":"60","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts":"61","/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx":"62","/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx":"63","/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts":"64","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts":"65","/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx":"66","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts":"67","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts":"68","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx":"69","/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx":"70","/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts":"71","/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts":"72","/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts":"73","/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx":"74","/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx":"75","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts":"76","/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts":"77","/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts":"78","/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx":"79","/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts":"80","/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx":"81","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts":"82","/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts":"83","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts":"84","/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts":"85","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts":"86","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts":"87","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts":"88","/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts":"89","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricIndexer.ts":"90","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageRenderer.ts":"91","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricRenderer.ts":"92","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/PaintingCanvasController.ts":"93","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageIndexer.ts":"94","/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayCanvasController.ts":"95","/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/program/OverlayGeometricRenderer.ts":"96","/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayMainCanvasRenderer.ts":"97","/Users/jani/Code/Web/dxpaint/src/canvas/util/util.ts":"98","/Users/jani/Code/Web/dxpaint/src/canvas/ZoomCanvasRenderer.ts":"99","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/ColorIndexer.ts":"100","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/MainCanvasRenderer.ts":"101","/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/program/OverlayDrawImageRenderer.ts":"102","/Users/jani/Code/Web/dxpaint/src/domain/LineV.ts":"103","/Users/jani/Code/Web/dxpaint/src/domain/LineH.ts":"104","/Users/jani/Code/Web/dxpaint/src/domain/Line.ts":"105","/Users/jani/Code/Web/dxpaint/src/canvas/util/webglUtil.ts":"106"},{"size":758,"mtime":1581006660054,"results":"107","hashOfConfig":"108"},{"size":1647,"mtime":1610123744119,"results":"109","hashOfConfig":"108"},{"size":2303,"mtime":1587397395180,"results":"110","hashOfConfig":"108"},{"size":1650,"mtime":1587397383935,"results":"111","hashOfConfig":"108"},{"size":4292,"mtime":1588883165180,"results":"112","hashOfConfig":"108"},{"size":1341,"mtime":1609964713351,"results":"113","hashOfConfig":"108"},{"size":99,"mtime":1570358386366,"results":"114","hashOfConfig":"108"},{"size":99,"mtime":1589653071467,"results":"115","hashOfConfig":"108"},{"size":99,"mtime":1581162181250,"results":"116","hashOfConfig":"108"},{"size":407,"mtime":1613232457299,"results":"117","hashOfConfig":"108"},{"size":5437,"mtime":1617126089378,"results":"118","hashOfConfig":"108"},{"size":712,"mtime":1586637521430,"results":"119","hashOfConfig":"108"},{"size":7811,"mtime":1619101178949,"results":"120","hashOfConfig":"108"},{"size":103,"mtime":1589645340777,"results":"121","hashOfConfig":"108"},{"size":238,"mtime":1589698799652,"results":"122","hashOfConfig":"108"},{"size":994,"mtime":1610288900130,"results":"123","hashOfConfig":"108"},{"size":2307,"mtime":1587665133808,"results":"124","hashOfConfig":"108"},{"size":3939,"mtime":1606591580738,"results":"125","hashOfConfig":"108"},{"size":775,"mtime":1598628605933,"results":"126","hashOfConfig":"108"},{"size":17045,"mtime":1619108624970,"results":"127","hashOfConfig":"108"},{"size":3874,"mtime":1618043735529,"results":"128","hashOfConfig":"108"},{"size":2427,"mtime":1598195635333,"results":"129","hashOfConfig":"108"},{"size":5449,"mtime":1598418063310,"results":"130","hashOfConfig":"108"},{"size":3330,"mtime":1617089360353,"results":"131","hashOfConfig":"108"},{"size":3137,"mtime":1614154844644,"results":"132","hashOfConfig":"108"},{"size":749,"mtime":1606592951751,"results":"133","hashOfConfig":"108"},{"size":1069,"mtime":1609948473281,"results":"134","hashOfConfig":"108"},{"size":419,"mtime":1586636737515,"results":"135","hashOfConfig":"108"},{"size":1292,"mtime":1615622215367,"results":"136","hashOfConfig":"108"},{"size":448,"mtime":1606592971846,"results":"137","hashOfConfig":"108"},{"size":990,"mtime":1606591610390,"results":"138","hashOfConfig":"108"},{"size":163,"mtime":1616686264476,"results":"139","hashOfConfig":"108"},{"size":787,"mtime":1610395467992,"results":"140","hashOfConfig":"108"},{"size":3492,"mtime":1598088214899,"results":"141","hashOfConfig":"108"},{"size":3708,"mtime":1618937272957,"results":"142","hashOfConfig":"108"},{"size":3014,"mtime":1617126089331,"results":"143","hashOfConfig":"108"},{"size":1686,"mtime":1596966551515,"results":"144","hashOfConfig":"108"},{"size":3174,"mtime":1618937585556,"results":"145","hashOfConfig":"108"},{"size":4424,"mtime":1598418176200,"results":"146","hashOfConfig":"108"},{"size":620,"mtime":1609948514564,"results":"147","hashOfConfig":"108"},{"size":1542,"mtime":1616932868894,"results":"148","hashOfConfig":"108"},{"size":1328,"mtime":1576359001814,"results":"149","hashOfConfig":"108"},{"size":3226,"mtime":1613738313456,"results":"150","hashOfConfig":"108"},{"size":849,"mtime":1582737330219,"results":"151","hashOfConfig":"108"},{"size":2134,"mtime":1618037345519,"results":"152","hashOfConfig":"108"},{"size":794,"mtime":1589698776952,"results":"153","hashOfConfig":"108"},{"size":5255,"mtime":1613737486628,"results":"154","hashOfConfig":"108"},{"size":1298,"mtime":1589699509988,"results":"155","hashOfConfig":"108"},{"size":99,"mtime":1570358390587,"results":"156","hashOfConfig":"108"},{"size":99,"mtime":1570358382606,"results":"157","hashOfConfig":"108"},{"size":99,"mtime":1570358454848,"results":"158","hashOfConfig":"108"},{"size":479,"mtime":1586285629987,"results":"159","hashOfConfig":"108"},{"size":691,"mtime":1582737314794,"results":"160","hashOfConfig":"108"},{"size":197,"mtime":1589653419630,"results":"161","hashOfConfig":"108"},{"size":1538,"mtime":1613232457299,"results":"162","hashOfConfig":"108"},{"size":2633,"mtime":1596966551507,"results":"163","hashOfConfig":"108"},{"size":4811,"mtime":1618049989393,"results":"164","hashOfConfig":"108"},{"size":1250,"mtime":1617126089377,"results":"165","hashOfConfig":"108"},{"size":2017,"mtime":1597691407920,"results":"166","hashOfConfig":"108"},{"size":99,"mtime":1589645298846,"results":"167","hashOfConfig":"108"},{"size":1651,"mtime":1617126089306,"results":"168","hashOfConfig":"108"},{"size":3882,"mtime":1618497552492,"results":"169","hashOfConfig":"108"},{"size":3797,"mtime":1596966551513,"results":"170","hashOfConfig":"108"},{"size":99,"mtime":1570358463891,"results":"171","hashOfConfig":"108"},{"size":3476,"mtime":1606591793814,"results":"172","hashOfConfig":"108"},{"size":2892,"mtime":1598418027518,"results":"173","hashOfConfig":"108"},{"size":221,"mtime":1609964687396,"results":"174","hashOfConfig":"108"},{"size":94,"mtime":1609948309696,"results":"175","hashOfConfig":"108"},{"size":1140,"mtime":1610122119190,"results":"176","hashOfConfig":"108"},{"size":2782,"mtime":1610122387748,"results":"177","hashOfConfig":"108"},{"size":3111,"mtime":1613738274657,"results":"178","hashOfConfig":"108"},{"size":1634,"mtime":1619191325128,"results":"179","hashOfConfig":"108"},{"size":1244,"mtime":1616930149618,"results":"180","hashOfConfig":"108"},{"size":3361,"mtime":1610827576318,"results":"181","hashOfConfig":"108"},{"size":6801,"mtime":1618068243707,"results":"182","hashOfConfig":"108"},{"size":99,"mtime":1609948228471,"results":"183","hashOfConfig":"108"},{"size":129,"mtime":1589653235884,"results":"184","hashOfConfig":"108"},{"size":424,"mtime":1611407191206,"results":"185","hashOfConfig":"108"},{"size":758,"mtime":1616082227415,"results":"186","hashOfConfig":"108"},{"size":5183,"mtime":1615012131754,"results":"187","hashOfConfig":"108"},{"size":4028,"mtime":1584903623805,"results":"188","hashOfConfig":"108"},{"size":6009,"mtime":1613307455776,"results":"189","hashOfConfig":"108"},{"size":7497,"mtime":1616689325520,"results":"190","hashOfConfig":"108"},{"size":6619,"mtime":1616699868078,"results":"191","hashOfConfig":"108"},{"size":3560,"mtime":1616699702251,"results":"192","hashOfConfig":"108"},{"size":3927,"mtime":1616828226913,"results":"193","hashOfConfig":"108"},{"size":6718,"mtime":1617125954596,"results":"194","hashOfConfig":"108"},{"size":4844,"mtime":1615909450457,"results":"195","hashOfConfig":"108"},{"size":1782,"mtime":1616930826393,"results":"196","hashOfConfig":"108"},{"size":5275,"mtime":1619191509501,"results":"197","hashOfConfig":"108"},{"size":2086,"mtime":1619184850511,"results":"198","hashOfConfig":"108"},{"size":4218,"mtime":1619191725461,"results":"199","hashOfConfig":"108"},{"size":9015,"mtime":1619107804525,"results":"200","hashOfConfig":"108"},{"size":5828,"mtime":1619191551996,"results":"201","hashOfConfig":"108"},{"size":5300,"mtime":1618243469649,"results":"202","hashOfConfig":"108"},{"size":4805,"mtime":1619191487637,"results":"203","hashOfConfig":"108"},{"size":1557,"mtime":1618243240466,"results":"204","hashOfConfig":"108"},{"size":1638,"mtime":1619191683528,"results":"205","hashOfConfig":"108"},{"size":1401,"mtime":1618043289183,"results":"206","hashOfConfig":"108"},{"size":3621,"mtime":1618676122692,"results":"207","hashOfConfig":"108"},{"size":1214,"mtime":1618676099942,"results":"208","hashOfConfig":"108"},{"size":5690,"mtime":1619191494405,"results":"209","hashOfConfig":"108"},{"size":565,"mtime":1618726558340,"results":"210","hashOfConfig":"108"},{"size":567,"mtime":1619191463704,"results":"211","hashOfConfig":"108"},{"size":180,"mtime":1618674251371,"results":"212","hashOfConfig":"108"},{"size":1587,"mtime":1617636966253,"results":"213","hashOfConfig":"108"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},"1plr3f1",{"filePath":"217","messages":"218","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"219","messages":"220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"221"},{"filePath":"222","messages":"223","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"224"},{"filePath":"225","messages":"226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"224"},{"filePath":"227","messages":"228","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"229"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"233","messages":"234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"239","messages":"240","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"241","messages":"242","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"243","usedDeprecatedRules":"244"},{"filePath":"245","messages":"246","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"247","messages":"248","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"249","usedDeprecatedRules":"238"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"256","messages":"257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"264"},{"filePath":"265","messages":"266","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"267","usedDeprecatedRules":"238"},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"270","messages":"271","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"274","usedDeprecatedRules":"244"},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"277","messages":"278","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"279","usedDeprecatedRules":"238"},{"filePath":"280","messages":"281","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"282","messages":"283","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"284","messages":"285","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"286","messages":"287","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"288","messages":"289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"292","messages":"293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"294","messages":"295","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"296","messages":"297","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"298","messages":"299","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"300","messages":"301","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"302","messages":"303","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"304","usedDeprecatedRules":"238"},{"filePath":"305","messages":"306","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"307","usedDeprecatedRules":"238"},{"filePath":"308","messages":"309","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"310","messages":"311","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"312","messages":"313","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"314","messages":"315","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"316","usedDeprecatedRules":"317"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"322","messages":"323","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"328","messages":"329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"330","messages":"331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"339","messages":"340","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"341","messages":"342","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"343","usedDeprecatedRules":"238"},{"filePath":"344","messages":"345","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"346","usedDeprecatedRules":"244"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"349","messages":"350","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"351","usedDeprecatedRules":"238"},{"filePath":"352","messages":"353","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"224"},{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"358","messages":"359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"360","messages":"361","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"362","messages":"363","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"364","messages":"365","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"366","messages":"367","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"368","usedDeprecatedRules":"244"},{"filePath":"369","messages":"370","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"371","messages":"372","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"373","messages":"374","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"375","messages":"376","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"224"},{"filePath":"377","messages":"378","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"379","messages":"380","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"383","messages":"384","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"385","messages":"386","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"387","usedDeprecatedRules":"244"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"224"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"235"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"398","usedDeprecatedRules":"235"},{"filePath":"399","messages":"400","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"401","messages":"402","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"403"},{"filePath":"404","messages":"405","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"406","usedDeprecatedRules":"229"},{"filePath":"407","messages":"408","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"409","usedDeprecatedRules":"403"},{"filePath":"410","messages":"411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"412","messages":"413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"414","messages":"415","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"416","messages":"417","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"418"},{"filePath":"419","messages":"420","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"421","messages":"422","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"423","messages":"424","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"425","messages":"426","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"427","messages":"428","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"429","messages":"430","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"431","messages":"432","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"244"},{"filePath":"433","messages":"434","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"435","messages":"436","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"238"},{"filePath":"437","messages":"438","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"439","messages":"440","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"441","messages":"442","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"443","usedDeprecatedRules":"238"},{"filePath":"444","messages":"445","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"446","messages":"447","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"448","messages":"449","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"450","messages":"451","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"452","messages":"453","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"454","messages":"455","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/jani/Code/Web/dxpaint/src/index.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/App.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx",["456","457"],"import React, { useEffect, useRef } from 'react';\nimport { CanvasStateAction } from './CanvasState';\nimport { useInitTool, useUndo, useFillStyle } from './hooks';\nimport { useOvermind } from '../../overmind';\nimport { getEventHandler, getEventHandlerOverlay } from '../../tools/util/util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\nimport './Canvas.css';\nimport { paintingCanvasController } from '../../canvas/paintingCanvas/PaintingCanvasController';\nimport { overlayCanvasController } from '../../canvas/overlayCanvas/OverlayCanvasController';\n\ninterface Props {\n  canvasDispatch: React.Dispatch<CanvasStateAction>;\n  isZoomCanvas: boolean;\n  zoomFactor?: number;\n}\n\nexport function Canvas({\n  canvasDispatch,\n  isZoomCanvas,\n  zoomFactor = 1,\n}: Props): JSX.Element | null {\n  console.log('render ' + (isZoomCanvas ? 'ZoomCanvas' : 'MainCanvas'));\n  const canvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const paintingCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlay2CanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n\n  useEffect((): void => {\n    canvasDispatch({\n      type: isZoomCanvas ? 'setZoomCanvas' : 'setMainCanvas',\n      elements: { canvas: canvasRef.current, overlay: overlayCanvasRef.current },\n    });\n    if (isZoomCanvas) {\n      paintingCanvasController.attachZoomCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachZoomCanvas(overlay2CanvasRef.current);\n    } else {\n      paintingCanvasController.attachMainCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachMainCanvas(overlay2CanvasRef.current);\n    }\n  }, []);\n\n  const canvasCtx = canvasRef.current.getContext('2d', {\n    alpha: false,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const overlayCanvasCtx = overlayCanvasRef.current.getContext('2d', {\n    alpha: true,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const { state, actions } = useOvermind();\n\n  const eventHandlerParams: EventHandlerParams = {\n    ctx: canvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setCanvasModified(isZoomCanvas);\n    },\n    undoPoint: (): void => {\n      actions.undo.setUndoPoint(canvasRef.current);\n    },\n  };\n  const eventHandlerParamsOverlay: EventHandlerParamsOverlay = {\n    ctx: overlayCanvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setOverlayCanvasModified(isZoomCanvas);\n    },\n  };\n\n  useUndo(canvasRef.current);\n  useInitTool(eventHandlerParams, eventHandlerParamsOverlay, isZoomCanvas);\n\n  useFillStyle(canvasCtx);\n  useFillStyle(overlayCanvasCtx);\n\n  if (!canvasCtx || !overlayCanvasCtx) {\n    return null; // no render\n  }\n\n  const tool = state.toolbox.activeTool;\n\n  const CSSZoom = {\n    width: state.canvas.resolution.width * zoomFactor,\n    height: state.canvas.resolution.height * zoomFactor,\n  };\n\n  return (\n    <>\n      <canvas\n        className=\"canvas\"\n        ref={canvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n        onClick={(event): void => {\n          getEventHandler(tool, 'onClick', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onClickOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseDown={(event): void => {\n          getEventHandler(tool, 'onMouseDown', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseDownOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseUp={(event): void => {\n          getEventHandler(tool, 'onMouseUp', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseUpOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseEnter={(event): void => {\n          getEventHandler(tool, 'onMouseEnter', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseEnterOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseLeave={(event): void => {\n          getEventHandler(tool, 'onMouseLeave', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseLeaveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseMove={(event): void => {\n          getEventHandler(tool, 'onMouseMove', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseMoveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onContextMenu={getEventHandler(tool, 'onContextMenu', eventHandlerParams)}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={paintingCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlay2CanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlayCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n    </>\n  );\n}\n",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx",[],"/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx",["458","459","460","461","462","463","464","465"],"import { BrushInterface } from './Brush';\nimport { Point, Color } from '../types';\nimport { drawImage } from '../algorithm/primitive';\nimport {\n  line,\n  unfilledRect,\n  filledRect,\n  unfilledCircle,\n  filledCircle,\n  curve,\n  unfilledEllipse,\n  filledEllipse,\n  filledPolygon,\n  unfilledPolygon,\n  line2,\n  unfilledRect2,\n  unfilledCircle2,\n  curve2,\n} from '../algorithm/shape';\nimport { overmind } from '../index';\nimport { colorToRGBString } from '../tools/util/util';\nimport { colorizeTexture } from '../colorIndex/util';\nimport { CanvasController } from '../canvas/CanvasController';\nimport { LineV } from '../domain/LineV';\nimport { LineH } from '../domain/LineH';\n\ninterface CustomBrushFeatures {\n  setFGColor(color: Color): void;\n  setBGColor(color: Color): void;\n  toFGColor(): void;\n  toBGColor(): void;\n  toMatte(): void;\n  getObjectURL(): string;\n}\n\nexport class CustomBrush implements BrushInterface, CustomBrushFeatures {\n  public brushImage = new Image(); // TODO: acts like getter, so maybe make it one\n  public brushColorIndex = new Uint8Array(); // TODO: acts like getter, so maybe make it one\n  public width = 0;\n  public heigth = 0;\n  public lastChanged = 0;\n  private brushImageMatte = new Image();\n  private brushImageColorFG = new Image();\n  private brushImageColorBG = new Image();\n  private brushColorIndexMatte = new Uint8Array();\n  private brushColorIndexColorFG = new Uint8Array();\n  private brushColorIndexColorBG = new Uint8Array();\n  public constructor(dataURL: string, colorIndex?: Uint8Array) {\n    this.brushImage.src = dataURL;\n    this.brushImage.onload = (): void => {\n      this.width = this.brushImage.width;\n      this.heigth = this.brushImage.height;\n      this.setFGColor(overmind.state.palette.foregroundColor);\n      this.setBGColor(overmind.state.palette.backgroundColor);\n      if (colorIndex) {\n        this.brushColorIndex = colorIndex;\n        this.brushColorIndexMatte = colorIndex;\n      }\n    };\n    this.brushImageMatte = this.brushImage;\n    this.lastChanged = Date.now();\n  }\n\n  public drawDot(ctx: CanvasRenderingContext2D, point: Point, canvas?: CanvasController): void {\n    const pointAdj = this.adjustHandle(point);\n    canvas?.drawImage?.([pointAdj], this);\n  }\n\n  private adjustHandle(point: Point): Point {\n    return { x: point.x - (this.width - 1) / 2, y: point.y - (this.heigth - 2) / 2 };\n  }\n\n  public drawLine(\n    ctx: CanvasRenderingContext2D,\n    start: Point,\n    end: Point,\n    canvas?: CanvasController\n  ): void {\n    const line = line2(this.adjustHandle(start), this.adjustHandle(end));\n    canvas?.drawImage?.(line, this);\n  }\n\n  public drawCurve(\n    ctx: CanvasRenderingContext2D,\n    start: Point,\n    end: Point,\n    middlePoint: Point,\n    canvas?: CanvasController\n  ): void {\n    const curve = curve2(\n      this.adjustHandle(start),\n      this.adjustHandle(end),\n      this.adjustHandle(middlePoint)\n    );\n    canvas?.drawImage?.(curve, this);\n  }\n\n  public drawLineVertical(ctx: CanvasRenderingContext2D, y1: number, y2: number, x: number): void {\n    let startY = y1;\n    let endY = y2;\n\n    if (y2 < y1) {\n      startY = y2;\n      endY = y1;\n    }\n\n    for (let y = startY; y <= endY; y++) {\n      this.drawDot(ctx, { x: x, y: y });\n    }\n  }\n\n  public drawLineHorizontal(\n    ctx: CanvasRenderingContext2D,\n    x1: number,\n    x2: number,\n    y: number\n  ): void {\n    let startX = x1;\n    let endX = x2;\n\n    if (x2 < x1) {\n      startX = x2;\n      endX = x1;\n    }\n\n    for (let x = startX; x <= endX; x++) {\n      this.drawDot(ctx, { x: x, y: y });\n    }\n  }\n\n  public drawUnfilledRect(\n    ctx: CanvasRenderingContext2D,\n    start: Point,\n    end: Point,\n    canvas: CanvasController\n  ): void {\n    const startAdj = this.adjustHandle(start);\n    const endAdj = this.adjustHandle(end);\n    const unfilledRect = unfilledRect2(startAdj, endAdj);\n    const unfilledRectAsPoints = [\n      ...unfilledRect[0].asPoints(),\n      ...unfilledRect[1].asPoints(),\n      ...unfilledRect[2].asPoints(),\n      ...unfilledRect[3].asPoints(),\n    ];\n    canvas?.drawImage?.(unfilledRectAsPoints, this);\n  }\n\n  public drawFilledRect(\n    ctx: CanvasRenderingContext2D,\n    start: Point,\n    end: Point,\n    canvas: CanvasController\n  ): void {\n    // DPaint just draws the filled shape as if using a pixel brush\n    canvas?.quad?.(start, end, overmind.state.tool.activeColorIndex);\n  }\n\n  public drawUnfilledCircle(\n    ctx: CanvasRenderingContext2D,\n    center: Point,\n    radius: number,\n    canvas: CanvasController\n  ): void {\n    const centerAdj = this.adjustHandle(center);\n    const unfilledCircle = unfilledCircle2(centerAdj, radius);\n    canvas?.drawImage?.(unfilledCircle, this);\n  }\n\n  public drawFilledCircle(ctx: CanvasRenderingContext2D, center: Point, radius: number): void {\n    filledCircle(ctx, this, center, radius);\n  }\n\n  public drawUnfilledEllipse(\n    ctx: CanvasRenderingContext2D,\n    center: Point,\n    radiusX: number,\n    radiusY: number,\n    rotationAngle: number\n  ): void {\n    unfilledEllipse(ctx, this, center, radiusX, radiusY, rotationAngle);\n  }\n\n  public drawFilledEllipse(\n    ctx: CanvasRenderingContext2D,\n    center: Point,\n    radiusX: number,\n    radiusY: number,\n    rotationAngle: number\n  ): void {\n    filledEllipse(ctx, this, center, radiusX, radiusY, rotationAngle);\n  }\n\n  public drawUnfilledPolygon(\n    ctx: CanvasRenderingContext2D,\n    vertices: Point[],\n    complete?: boolean\n  ): void {\n    unfilledPolygon(ctx, this, vertices, complete);\n  }\n\n  public drawFilledPolygon(ctx: CanvasRenderingContext2D, vertices: Point[]): void {\n    filledPolygon(ctx, this, vertices);\n  }\n\n  // CustomBrushFeatures\n\n  public setFGColor(color: Color): void {\n    // colorize brush image\n\n    const bufferCanvas = document.createElement('canvas');\n    bufferCanvas.width = Math.abs(this.width);\n    bufferCanvas.height = Math.abs(this.heigth);\n\n    const ctx = bufferCanvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n\n    ctx.fillStyle = colorToRGBString(color);\n    ctx.fillRect(0, 0, this.width, this.heigth);\n    ctx.globalCompositeOperation = 'destination-in';\n    ctx.drawImage(this.brushImage, 0, 0);\n    this.brushImageColorFG.src = bufferCanvas.toDataURL();\n\n    // colorize color index\n\n    this.brushColorIndexColorFG = colorizeTexture(\n      this.brushColorIndex,\n      Number(overmind.state.palette.foregroundColorId)\n    );\n    if (overmind.state.brush.mode === 'Color') {\n      this.toFGColor(); // must be set here for fg color, not ideal:(\n    }\n  }\n\n  public setBGColor(color: Color): void {\n    // colorize brush image\n\n    const bufferCanvas = document.createElement('canvas');\n    bufferCanvas.width = Math.abs(this.width);\n    bufferCanvas.height = Math.abs(this.heigth);\n\n    const ctx = bufferCanvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n\n    ctx.fillStyle = colorToRGBString(color);\n    ctx.fillRect(0, 0, this.width, this.heigth);\n    ctx.globalCompositeOperation = 'destination-in';\n    ctx.drawImage(this.brushImage, 0, 0);\n    this.brushImageColorBG.src = bufferCanvas.toDataURL();\n\n    // colorize color index\n\n    this.brushColorIndexColorBG = colorizeTexture(\n      this.brushColorIndex,\n      Number(overmind.state.palette.backgroundColorId)\n    );\n  }\n\n  public toFGColor(): void {\n    this.brushImage = this.brushImageColorFG;\n    this.brushColorIndex = this.brushColorIndexColorFG;\n    this.lastChanged = Date.now();\n  }\n\n  public toBGColor(): void {\n    this.brushImage = this.brushImageColorBG;\n    this.brushColorIndex = this.brushColorIndexColorBG;\n    this.lastChanged = Date.now();\n  }\n\n  public toMatte(): void {\n    this.brushImage = this.brushImageMatte;\n    this.brushColorIndex = this.brushColorIndexMatte;\n    this.lastChanged = Date.now();\n  }\n\n  public getObjectURL(): string {\n    return this.brushImage.src;\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts",["466"],"// Algorithms for composing shapes using primitives\n\nimport { Line, Point } from '../types';\nimport { BrushInterface } from '../brush/Brush';\nimport { fillRect } from './primitive';\nimport { CanvasController } from '../canvas/CanvasController';\nimport { LineH } from '../domain/LineH';\nimport { LineV } from '../domain/LineV';\n\nexport function line(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  start: Point,\n  end: Point,\n  canvas?: CanvasController\n): void {\n  const dist = Math.round(distance(start, end));\n  if (dist === 0) {\n    // just draw a dot\n    brush.drawDot(ctx, start, canvas);\n    return;\n  }\n\n  const cx = (end.x - start.x) / dist;\n  const cy = (end.y - start.y) / dist;\n\n  for (let i = 0; i <= dist; i++) {\n    brush.drawDot(\n      ctx,\n      {\n        x: Math.floor(start.x + cx * i),\n        y: Math.floor(start.y + cy * i),\n      },\n      canvas\n    );\n  }\n}\n\nexport function line2(start: Point, end: Point): Point[] {\n  const dist = Math.round(distance(start, end));\n  if (dist === 0) {\n    // just draw a dot\n    return [{ x: start.x, y: start.y }];\n  }\n\n  const cx = (end.x - start.x) / dist;\n  const cy = (end.y - start.y) / dist;\n\n  const line: Point[] = [];\n\n  for (let i = 0; i <= dist; i++) {\n    line.push({ x: Math.floor(start.x + cx * i), y: Math.floor(start.y + cy * i) });\n  }\n  return line;\n}\n\nexport function distance(start: Point, end: Point): number {\n  return Math.sqrt((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y));\n}\n\n// Quadratic bezier curve with one control point.\n// DPaint used conic curves instead.\nexport function curve2(start: Point, end: Point, middlePoint: Point): Point[] {\n  // calculate control point for the bezier curve when middlepoint given\n  const controlPoint: Point = {\n    x: 2 * middlePoint.x - 0.5 * start.x - 0.5 * end.x,\n    y: 2 * middlePoint.y - 0.5 * start.y - 0.5 * end.y,\n  };\n\n  const curve: Point[] = [];\n\n  let i: number;\n  let previous: Point = start;\n  // TODO: get rid of the magic number\n  for (i = 0; i <= 1; i = i + 0.02) {\n    const current = getQuadraticXY(i, start, controlPoint, end);\n    curve.push(...line2(previous, current));\n    previous = current;\n  }\n  curve.push(...line2(previous, end));\n\n  return curve;\n}\n\n// Quadratic bezier curve with one control point.\n// DPaint used conic curves instead.\nexport function curve(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  start: Point,\n  end: Point,\n  middlePoint: Point\n): void {\n  // calculate control point for the bezier curve when middlepoint given\n  const controlPoint: Point = {\n    x: 2 * middlePoint.x - 0.5 * start.x - 0.5 * end.x,\n    y: 2 * middlePoint.y - 0.5 * start.y - 0.5 * end.y,\n  };\n\n  let i: number;\n  let previous: Point = start;\n  // TODO: get rid of the magic number\n  for (i = 0; i <= 1; i = i + 0.02) {\n    const current = getQuadraticXY(i, start, controlPoint, end);\n    line(ctx, brush, previous, current);\n    previous = current;\n  }\n  line(ctx, brush, previous, end);\n}\n\nfunction getQuadraticXY(t: number, start: Point, controlPoint: Point, end: Point): Point {\n  return {\n    x: Math.round((1 - t) * (1 - t) * start.x + 2 * (1 - t) * t * controlPoint.x + t * t * end.x),\n    y: Math.round((1 - t) * (1 - t) * start.y + 2 * (1 - t) * t * controlPoint.y + t * t * end.y),\n  };\n}\n\nexport function unfilledRect(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  start: Point,\n  end: Point\n): void {\n  if (start === end) {\n    // just draw a dot\n    brush.drawDot(ctx, start);\n    return;\n  }\n\n  // rectangle limits\n\n  const y1 = start.y;\n  const y2 = end.y;\n  const x1 = start.x;\n  const x2 = end.x;\n\n  // draw lines\n\n  brush.drawLineHorizontal(ctx, x1, x2, y1);\n  brush.drawLineHorizontal(ctx, x1, x2, y2);\n  brush.drawLineVertical(ctx, y1, y2, x1);\n  brush.drawLineVertical(ctx, y1, y2, x2);\n}\n\nexport function unfilledRect2(start: Point, end: Point): (LineH | LineV)[] {\n  if (start === end) {\n    // just draw a dot\n    return [new LineH({ x: start.x, y: start.y }, { x: start.x, y: start.y })];\n  }\n\n  // rectangle vertices\n\n  const v1 = start;\n  const v2 = { x: start.x, y: end.y };\n  const v3 = end;\n  const v4 = { x: end.x, y: start.y };\n\n  const rect = [];\n  rect.push(new LineV(v1, v2));\n  rect.push(new LineH(v2, v3));\n  rect.push(new LineV(v3, v4));\n  rect.push(new LineH(v4, v1));\n\n  return rect;\n}\n\nexport function filledRect(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  start: Point,\n  end: Point\n): void {\n  if (start === end) {\n    // just draw a dot\n    fillRect(start.x, start.y, 1, 1, ctx);\n    return;\n  }\n\n  const width = end.x - start.x;\n  const height = end.y - start.y;\n  fillRect(start.x, start.y, width, height, ctx);\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/45743774/fastest-way-to-draw-and-fill-a-not-anti-aliasing-circle-in-html5canvas\nexport function filledCircle(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  center: Point,\n  r: number\n): void {\n  if (r === 0) {\n    // just draw a dot\n    fillRect(center.x, center.y, 1, 1, ctx);\n    return;\n  }\n\n  let x = r;\n  let y = 0;\n  let cd = 0;\n\n  // middle line\n  fillRect(center.x - x, center.y, r << 1, 1, ctx);\n\n  while (x > y) {\n    cd -= --x - ++y;\n    if (cd < 0) cd += x++;\n    fillRect(center.x - y, center.y - x, y << 1, 1, ctx); // upper 1/4\n    fillRect(center.x - x, center.y - y, x << 1, 1, ctx); // upper 2/4\n    fillRect(center.x - x, center.y + y, x << 1, 1, ctx); // lower 3/4\n    fillRect(center.x - y, center.y + x, y << 1, 1, ctx); // lower 4/4\n  }\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/45743774/fastest-way-to-draw-and-fill-a-not-anti-aliasing-circle-in-html5canvas\nexport function filledCircle2(center: Point, r: number): LineH[] {\n  if (r === 0) {\n    // just draw a dot\n    return [new LineH({ x: center.x, y: center.y }, { x: center.x, y: center.y })];\n  }\n\n  let x = r;\n  let y = 0;\n  let cd = 0;\n\n  const circle: LineH[] = [];\n  // middle line\n  circle[0] = new LineH(\n    { x: center.x - x, y: center.y },\n    { x: center.x - x + (r << 1), y: center.y }\n  );\n\n  while (x > y) {\n    cd -= --x - ++y;\n    if (cd < 0) cd += x++;\n    circle.push(\n      new LineH(\n        { x: center.x - y, y: center.y - x },\n        { x: center.x - y + (y << 1), y: center.y - x }\n      )\n    );\n    circle.push(\n      new LineH(\n        { x: center.x - x, y: center.y - y },\n        { x: center.x - x + (x << 1), y: center.y - y }\n      )\n    );\n    circle.push(\n      new LineH(\n        { x: center.x - x, y: center.y + y },\n        { x: center.x - x + (x << 1), y: center.y + y }\n      )\n    );\n    circle.push(\n      new LineH(\n        { x: center.x - y, y: center.y + x },\n        { x: center.x - y + (y << 1), y: center.y + x }\n      )\n    );\n  }\n\n  return circle;\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/45743774/fastest-way-to-draw-and-fill-a-not-anti-aliasing-circle-in-html5canvas\nexport function unfilledCircle(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  center: Point,\n  r: number\n): void {\n  if (r === 0) {\n    // just draw a dot\n    brush.drawDot(ctx, center);\n    return;\n  }\n\n  let x = r,\n    y = 0,\n    cd = 0;\n\n  // middle points\n  brush.drawDot(ctx, { x: center.x - x, y: center.y });\n  brush.drawDot(ctx, { x: center.x + x, y: center.y });\n  brush.drawDot(ctx, { x: center.x, y: center.y - r });\n  brush.drawDot(ctx, { x: center.x, y: center.y + r });\n\n  // octants\n  while (x > y) {\n    cd -= --x - ++y;\n    if (cd < 0) cd += x++;\n    brush.drawDot(ctx, { x: center.x - y, y: center.y - x });\n    brush.drawDot(ctx, { x: center.x - x, y: center.y - y });\n    brush.drawDot(ctx, { x: center.x - x, y: center.y + y });\n    brush.drawDot(ctx, { x: center.x - y, y: center.y + x });\n\n    brush.drawDot(ctx, { x: center.x + y, y: center.y + x });\n    brush.drawDot(ctx, { x: center.x + x, y: center.y + y });\n    brush.drawDot(ctx, { x: center.x + x, y: center.y - y });\n    brush.drawDot(ctx, { x: center.x + y, y: center.y - x });\n  }\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/45743774/fastest-way-to-draw-and-fill-a-not-anti-aliasing-circle-in-html5canvas\nexport function unfilledCircle2(center: Point, r: number): Point[] {\n  if (r === 0) {\n    // just draw a dot\n    //brush.drawDot(ctx, center);\n    return [center];\n  }\n\n  let x = r,\n    y = 0,\n    cd = 0;\n\n  const circle: Point[] = [];\n\n  // middle points\n  circle.push({ x: center.x - x, y: center.y });\n  circle.push({ x: center.x + x, y: center.y });\n  circle.push({ x: center.x, y: center.y - r });\n  circle.push({ x: center.x, y: center.y + r });\n  /*   brush.drawDot(ctx, { x: center.x - x, y: center.y });\n  brush.drawDot(ctx, { x: center.x + x, y: center.y });\n  brush.drawDot(ctx, { x: center.x, y: center.y - r });\n  brush.drawDot(ctx, { x: center.x, y: center.y + r }); */\n\n  // octants\n  while (x > y) {\n    cd -= --x - ++y;\n    if (cd < 0) cd += x++;\n    circle.push({ x: center.x - y, y: center.y - x });\n    circle.push({ x: center.x - x, y: center.y - y });\n    circle.push({ x: center.x - x, y: center.y + y });\n    circle.push({ x: center.x - y, y: center.y + x });\n    /*     brush.drawDot(ctx, { x: center.x - y, y: center.y - x });\n    brush.drawDot(ctx, { x: center.x - x, y: center.y - y });\n    brush.drawDot(ctx, { x: center.x - x, y: center.y + y });\n    brush.drawDot(ctx, { x: center.x - y, y: center.y + x }); */\n\n    circle.push({ x: center.x + y, y: center.y + x });\n    circle.push({ x: center.x + x, y: center.y + y });\n    circle.push({ x: center.x + x, y: center.y - y });\n    circle.push({ x: center.x + y, y: center.y - x });\n    /*     brush.drawDot(ctx, { x: center.x + y, y: center.y + x });\n    brush.drawDot(ctx, { x: center.x + x, y: center.y + y });\n    brush.drawDot(ctx, { x: center.x + x, y: center.y - y });\n    brush.drawDot(ctx, { x: center.x + y, y: center.y - x }); */\n  }\n\n  return circle;\n}\n\nexport function unfilledEllipse(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  center: Point,\n  radiusX: number,\n  radiusY: number,\n  rotationAngle: number\n): void {\n  // eslint-disable-next-line max-len\n  // https://www.wolframalpha.com/input/?i=%28%28x*cos%28k%29+%2B+y*sin%28k%29%29%5E2%29%2Fa%5E2+%2B+%28%28x*sin%28k%29+-+y*cos%28k%29%29%5E2%29%2Fb%5E2+%3D+1\n  const a = radiusX;\n  const b = radiusY;\n  const phi = rotationAngle * (Math.PI / 180);\n\n  const xStart = Math.ceil(-Math.sqrt(a ** 2 * Math.cos(phi) ** 2 + b ** 2 * Math.sin(phi) ** 2));\n  const xEnd = -xStart;\n  if (xEnd === xStart) {\n    return;\n  }\n\n  // Define some constants for calculation\n\n  const a2 = a ** 2;\n  const b2 = b ** 2;\n  const ab = a * b;\n  const k = 2 * (Math.sin(phi) ** 2 / a2 + Math.cos(phi) ** 2 / b2);\n  const sinphicosphi = Math.sin(phi) * Math.cos(phi);\n  const cos2phi = Math.cos(2 * phi);\n  const c = a2 * cos2phi + a2 - b2 * cos2phi + b2;\n  const sqrt2 = Math.sqrt(2);\n\n  // Calculate y points of ellipse given x points\n\n  const ellipsePointsLowerHalf: Point[] = [];\n  const ellipsePointsUpperHalf: Point[] = [];\n  for (let x = xStart; x <= xEnd; x++) {\n    const nominator = sqrt2 * Math.sqrt(c - 2 * x ** 2);\n    let y1 = nominator / ab - (2 * x * sinphicosphi) / a2 + (2 * x * sinphicosphi) / b2;\n    y1 = Math.round(y1 / k);\n    let y2 = -nominator / ab - (2 * x * sinphicosphi) / a2 + (2 * x * sinphicosphi) / b2;\n    y2 = Math.round(y2 / k);\n    ellipsePointsLowerHalf.push({ x: x + center.x, y: y1 + center.y });\n    ellipsePointsUpperHalf.push({ x: x + center.x, y: y2 + center.y });\n  }\n\n  // Draw ellipse\n\n  // Lower half\n\n  for (let i = 1; i < ellipsePointsLowerHalf.length - 1; i++) {\n    const point = ellipsePointsLowerHalf[i];\n    const previousPoint = ellipsePointsLowerHalf[i - 1];\n    const nextPoint = ellipsePointsLowerHalf[i + 1];\n    if (point.y > previousPoint.y + 1) {\n      brush.drawLineVertical(ctx, previousPoint.y + 1, point.y, point.x);\n    } else if (point.y > nextPoint.y + 1) {\n      brush.drawLineVertical(ctx, nextPoint.y + 1, point.y, point.x);\n    } else {\n      brush.drawDot(ctx, point);\n    }\n  }\n\n  // Upper half\n\n  for (let i = 1; i < ellipsePointsUpperHalf.length - 1; i++) {\n    const point = ellipsePointsUpperHalf[i];\n    const previousPoint = ellipsePointsUpperHalf[i - 1];\n    const nextPoint = ellipsePointsUpperHalf[i + 1];\n    if (point.y < previousPoint.y - 1) {\n      brush.drawLineVertical(ctx, point.y, previousPoint.y - 1, point.x);\n    } else if (point.y < nextPoint.y - 1) {\n      brush.drawLineVertical(ctx, point.y, nextPoint.y - 1, point.x);\n    } else {\n      brush.drawDot(ctx, point);\n    }\n  }\n\n  // Close both ends of ellipse by drawing a vertical line at x = 0 and x = length - 1\n\n  const startYLower = ellipsePointsLowerHalf[0].y;\n  const startYUpper = ellipsePointsUpperHalf[0].y;\n  const startX = ellipsePointsUpperHalf[0].x;\n  brush.drawLineVertical(ctx, startYLower, startYUpper - 1, startX);\n  brush.drawDot(ctx, ellipsePointsLowerHalf[0]);\n\n  const endYLower = ellipsePointsLowerHalf[ellipsePointsUpperHalf.length - 1].y;\n  const endYUpper = ellipsePointsUpperHalf[ellipsePointsUpperHalf.length - 1].y;\n  const endX = ellipsePointsUpperHalf[ellipsePointsUpperHalf.length - 1].x;\n  brush.drawLineVertical(ctx, endYLower, endYUpper - 1, endX);\n  brush.drawDot(ctx, ellipsePointsLowerHalf[ellipsePointsUpperHalf.length - 1]);\n}\n\nexport function filledEllipse(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  center: Point,\n  radiusX: number,\n  radiusY: number,\n  rotationAngle: number\n): void {\n  // eslint-disable-next-line max-len\n  // https://www.wolframalpha.com/input/?i=%28%28x*cos%28k%29+%2B+y*sin%28k%29%29%5E2%29%2Fa%5E2+%2B+%28%28x*sin%28k%29+-+y*cos%28k%29%29%5E2%29%2Fb%5E2+%3D+1\n  const a = radiusX;\n  const b = radiusY;\n  const phi = rotationAngle * (Math.PI / 180);\n\n  const xStart = Math.ceil(-Math.sqrt(a ** 2 * Math.cos(phi) ** 2 + b ** 2 * Math.sin(phi) ** 2));\n  const xEnd = -xStart;\n\n  // Define some constants for calculation\n\n  const a2 = a ** 2;\n  const b2 = b ** 2;\n  const ab = a * b;\n  const k = 2 * (Math.sin(phi) ** 2 / a2 + Math.cos(phi) ** 2 / b2);\n  const sinphicosphi = Math.sin(phi) * Math.cos(phi);\n  const cos2phi = Math.cos(2 * phi);\n  const c = a2 * cos2phi + a2 - b2 * cos2phi + b2;\n  const sqrt2 = Math.sqrt(2);\n\n  for (let x = xStart; x <= xEnd; x++) {\n    const nominator = sqrt2 * Math.sqrt(c - 2 * x ** 2);\n    let y1 = nominator / ab - (2 * x * sinphicosphi) / a2 + (2 * x * sinphicosphi) / b2;\n    y1 = Math.round(y1 / k);\n    let y2 = -nominator / ab - (2 * x * sinphicosphi) / a2 + (2 * x * sinphicosphi) / b2;\n    y2 = Math.round(y2 / k);\n    const h = Math.abs(y1 - y2);\n\n    fillRect(x + center.x, y1 + center.y, 1, -h, ctx);\n  }\n}\n\nexport function unfilledPolygon(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  vertices: Point[],\n  complete = true\n): void {\n  for (let i = 1; i < vertices.length; i++) {\n    brush.drawLine(ctx, vertices[i - 1], vertices[i]);\n  }\n  if (complete) {\n    brush.drawLine(ctx, vertices[vertices.length - 1], vertices[0]);\n  }\n}\n\n// adapted from https://alienryderflex.com/polygon_fill/\n// TODO: must also draw the outline of the polygon\nexport function filledPolygon(\n  ctx: CanvasRenderingContext2D,\n  brush: BrushInterface,\n  vertices: Point[]\n): void {\n  // first draw the outline\n  //unfilledPolygon(ctx, new PixelBrush(), vertices);\n\n  const imageTop = Math.min(...vertices.map((point): number => point.y));\n  const imageBottom = Math.max(...vertices.map((point): number => point.y));\n  const imageLeft = Math.min(...vertices.map((point): number => point.x));\n  const imageRight = Math.max(...vertices.map((point): number => point.x));\n\n  const nodeX: number[] = [];\n\n  //  Loop through the rows of the image.\n  for (let pixelY = imageTop; pixelY < imageBottom; pixelY++) {\n    //  Build a list of nodes.\n    let nodes = 0;\n    const polyCorners = vertices.length;\n    let j = polyCorners - 1;\n    for (let i = 0; i < polyCorners; i++) {\n      if (\n        (vertices[i].y < pixelY && vertices[j].y >= pixelY) ||\n        (vertices[j].y < pixelY && vertices[i].y >= pixelY)\n      ) {\n        nodeX[nodes++] = Math.round(\n          vertices[i].x +\n            ((pixelY - vertices[i].y) / (vertices[j].y - vertices[i].y)) *\n              (vertices[j].x - vertices[i].x)\n        );\n      }\n      j = i;\n    }\n\n    //  Sort the nodes, via a simple Bubble sort.\n    let i = 0;\n    while (i < nodes - 1) {\n      if (nodeX[i] > nodeX[i + 1]) {\n        const swap = nodeX[i];\n        nodeX[i] = nodeX[i + 1];\n        nodeX[i + 1] = swap;\n        if (i) i--;\n      } else {\n        i++;\n      }\n    }\n\n    //  Fill the pixels between node pairs.\n    for (i = 0; i < nodes; i += 2) {\n      if (nodeX[i] >= imageRight) break;\n      if (nodeX[i + 1] > imageLeft) {\n        if (nodeX[i] < imageLeft) nodeX[i] = imageLeft;\n        if (nodeX[i + 1] > imageRight) nodeX[i + 1] = imageRight;\n        fillRect(nodeX[i], pixelY, nodeX[i + 1] - nodeX[i], 1, ctx);\n      }\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx",["467","468","469","470"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n  pointEquals,\n  points8Connected,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\nimport { paintingCanvasController } from '../canvas/paintingCanvas/PaintingCanvasController';\nimport { overlayCanvasController } from '../canvas/overlayCanvas/OverlayCanvasController';\n\nexport class FreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.freeHandToolPrevious(null);\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons && overmind.state.tool.freehandTool.previous) {\n      const mousePos = getMousePos(canvas, event);\n      const start = overmind.state.tool.freehandTool.previous;\n      const end = mousePos;\n      if (pointEquals(start, end)) {\n        return; // this point has already been drawn to canvas\n      }\n      if (points8Connected(start, end)) {\n        brushHistory.current.drawDot(ctx, end, paintingCanvasController);\n      } else {\n        brushHistory.current.drawLine(ctx, start, end, paintingCanvasController);\n      }\n      overmind.actions.tool.freeHandToolPrevious(end);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos, paintingCanvasController);\n    overmind.actions.tool.freeHandToolPrevious(mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    //clearOverlayCanvas(canvas);\n    const mousePos = getMousePos(canvas, event);\n    //brushHistory.current.drawDot(ctx, mousePos);\n    brushHistory.current.drawDot(ctx, mousePos, overlayCanvasController);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    //clearOverlayCanvas(canvas);\n    overlayCanvasController.clear();\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    //clearOverlayCanvas(canvas);\n    overlayCanvasController.clear();\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx",["471"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class AirbrushTool implements Tool {\n  private timeout = 0;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    overmind.actions.tool.airbrushToolPosition(mousePos);\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx, onPaint } = params;\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const draw = (ctx: CanvasRenderingContext2D, onPaint: Function): void => {\n      for (let i = 50; i--; ) {\n        const angle = getRandomFloat(0, Math.PI * 2);\n        const radius = getRandomFloat(0, 20);\n        if (overmind.state.tool.airbrushTool.position) {\n          brushHistory.current.drawDot(ctx, {\n            x: overmind.state.tool.airbrushTool.position.x + radius * Math.cos(angle),\n            y: overmind.state.tool.airbrushTool.position.y + radius * Math.sin(angle),\n          });\n        }\n      }\n      onPaint();\n      this.timeout = setTimeout(draw, 20, ctx, onPaint);\n    };\n\n    this.prepareToPaint(isRightMouseButton(event));\n    this.timeout = setTimeout(draw, 20, ctx, onPaint);\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    const { event, undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    if (isLeftOrRightMouseButton(event)) {\n      undoPoint();\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n\nfunction getRandomFloat(min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx",["472"],"export class Throttle {\n  private milliSecs: number;\n  private lastFunc: NodeJS.Timeout | null;\n  private lastRan: number | null;\n\n  public constructor(milliSecs: number) {\n    this.milliSecs = milliSecs;\n    this.lastFunc = null;\n    this.lastRan = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  public call(func: Function): void {\n    if (!this.lastRan) {\n      func();\n      this.lastRan = Date.now();\n    } else {\n      if (this.lastFunc) {\n        clearTimeout(this.lastFunc);\n      }\n      this.lastFunc = setTimeout(() => {\n        if (Date.now() - this.lastRan! >= this.milliSecs) {\n          func();\n          this.lastRan = Date.now();\n        }\n      }, this.milliSecs - (Date.now() - this.lastRan));\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx",["473","474","475","476","477","478","479"],"/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx",["480"],"/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx",["481"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { Throttle } from './util/Throttle';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\nimport { paintingCanvasController } from '../canvas/paintingCanvas/PaintingCanvasController';\nimport { overlayCanvasController } from '../canvas/overlayCanvas/OverlayCanvasController';\n\nexport class CurveTool implements Tool {\n  private throttle = new Throttle(50);\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.curveToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const endPoint = overmind.state.tool.curveTool.end;\n\n    if (endPoint) {\n      brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos, paintingCanvasController);\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n    } else {\n      overmind.actions.tool.curveToolEnd(mousePos);\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    if (!overmind.state.tool.curveTool.end) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.curveToolStart(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos, overlayCanvasController);\n      onPaint();\n      return;\n    }\n\n    const endPoint = overmind.state.tool.curveTool.end;\n    if (endPoint) {\n      brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos, overlayCanvasController);\n    } else if (isLeftOrRightMouseButton(event)) {\n      brushHistory.current.drawLine(ctx, startPoint, mousePos, overlayCanvasController);\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx",["482"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  pointEquals,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { Throttle } from './util/Throttle';\nimport { unfilledPolygon } from '../algorithm/shape';\nimport { PixelBrush } from '../brush/PixelBrush';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class PolygonTool implements Tool {\n  private throttle = new Throttle(20);\n  public constructor(filled: boolean) {\n    this.filled = filled;\n  }\n  private filled: boolean;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.polygonToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    // first click (left or right) determines polygon fill color\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      this.prepareToPaint(isRightMouseButton(event));\n      overmind.actions.tool.polygonToolAddVertice(mousePos);\n      return;\n    }\n\n    // complete polygon on right click or if starting point reselected\n    if (\n      isRightMouseButton(event) ||\n      pointEquals(overmind.state.tool.polygonTool.vertices[0], mousePos)\n    ) {\n      if (this.filled) {\n        brushHistory.current.drawFilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      }\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n      return;\n    }\n\n    // otherwise just add new vertice\n    overmind.actions.tool.polygonToolAddVertice(mousePos);\n  }\n\n  // Overlay\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 1) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n    }\n    onPaint();\n  }\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    if (this.filled) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        unfilledPolygon(\n          ctx,\n          new PixelBrush(),\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    } else {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 0) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n      onPaint();\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx",["483","484"],"import { Point } from '../../types';\nimport { useEffect } from 'react';\nimport { useOvermind } from '../../overmind';\nimport { undoBuffer } from '../../overmind/undo/UndoBuffer';\nimport { blobToCanvas } from './util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\n//import { renderToCanvasFrom } from '../../colorIndex/ColorIndexer';\n\nexport function useInitTool(\n  eventHandlerParams: EventHandlerParams,\n  eventHandlerParamsOverlay: EventHandlerParamsOverlay,\n  isZoomCanvas: boolean\n): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.previousTool?.onExit?.(eventHandlerParams);\n      state.toolbox.previousTool?.onExitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.previousTool]);\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.activeTool.onInit?.(eventHandlerParams);\n      state.toolbox.activeTool.onInitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.activeTool]);\n}\n\n// Update current fillStyle from state to canvas context when:\n// 1. fillStyle has been changed\n// 2. canvas resolution changes, as this also resets context\nexport function useFillStyle(ctx: CanvasRenderingContext2D | null): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (ctx) {\n      ctx.fillStyle = state.canvas.fillStyle;\n      ctx.strokeStyle = state.canvas.fillStyle;\n    }\n  }, [state.canvas.fillStyle, state.canvas.resolution]);\n}\n\nexport function useUndo(canvas: HTMLCanvasElement): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    //blobToCanvas(state.undo.currentBufferItem, canvas);\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (state.undo.currentIndex === null) {\n        return;\n      }\n      const colorIndex = undoBuffer.getItem(state.undo.currentIndex);\n      //renderToCanvasFrom(ctx, colorIndex);\n    }\n    console.log('undo hook end');\n  }, [state.undo.lastUndoRedoTime]);\n}\n\n// Load image to canvas when loadedImageURL changes\n// Changes canvas height and width to match image\nexport function useLoadedImage(canvas: HTMLCanvasElement): void {\n  const { state, actions } = useOvermind();\n  useEffect((): void => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n    const image = new Image();\n    image.onload = function (): void {\n      // No need to clear canvas, as changing dimensions clears it anyway.\n      // Note that context is also reset\n      actions.canvas.setResolution({ width: image.width, height: image.height });\n      ctx.drawImage(image, 0, 0);\n      actions.undo.setUndoPoint(canvas);\n      actions.canvas.setCanvasModified(false);\n    };\n    image.src = state.canvas.loadedImageURL;\n  }, [state.canvas.loadedImageURL]);\n}\n\nexport function useScrollToFocusPoint(\n  canvasDiv: HTMLDivElement,\n  focusPoint: Point | null,\n  zoomFactor = 1\n): void {\n  useEffect((): void => {\n    if (focusPoint === null) {\n      return;\n    }\n    const scrollOptions = {\n      left: focusPoint.x * zoomFactor - canvasDiv.clientWidth / 2,\n      top: focusPoint.y * zoomFactor - canvasDiv.clientHeight / 2,\n    };\n    canvasDiv.scrollTo(scrollOptions);\n  }, [focusPoint]);\n}\n",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx",["485"],"/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts",["486","487"],"import { Action } from 'overmind';\nimport { BrushInterface } from '../../brush/Brush';\nimport { Mode, BuiltInBrushId, builtInBrushes } from './state';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { brushHistory } from '../../brush/BrushHistory';\n\nexport const setBrush: Action<BrushInterface> = ({ state }, brush): void => {\n  brushHistory.set(brush);\n};\n\nexport const selectBuiltInBrush: Action<BuiltInBrushId> = (\n  { state, actions },\n  brushNumber\n): void => {\n  state.brush.selectedBuiltInBrushId = brushNumber;\n  actions.brush.setBrush(builtInBrushes[brushNumber]);\n  actions.brush.setMode('Color');\n};\n\nexport const setMode: Action<Mode> = ({ state }, mode): void => {\n  state.brush.mode = mode;\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    if (mode === 'Color') {\n      brush.setFGColor(state.palette.foregroundColor);\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toFGColor();\n    } else if (mode === 'Matte') {\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toMatte();\n    }\n  }\n};\n\nexport const toFGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (state.brush.mode === 'Color' && brush instanceof CustomBrush) {\n    brush.toFGColor();\n  }\n  if (state.brush.mode === 'Matte' && brush instanceof CustomBrush) {\n    brush.toMatte();\n  }\n};\n\nexport const toBGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    brush.toBGColor();\n  }\n};\n","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx",["488"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport { getMousePos, clearOverlayCanvas, extractBrush } from './util/util';\nimport { overmind } from '../index';\nimport { selection } from './util/SelectionIndicator';\n\nexport class BrushSelector implements Tool {\n  public onInit(params: EventHandlerParams): void {\n    const {\n      ctx: { canvas },\n    } = params;\n    overmind.actions.tool.brushSelectionStart(null);\n    selection.prepare(canvas);\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const width = mousePos.x - start.x;\n    const height = mousePos.y - start.y;\n\n    const brush = extractBrush(canvas, start, width, height);\n    overmind.actions.brush.setBrush(brush);\n    overmind.actions.brush.setMode('Matte');\n\n    // exit brush selection tool\n    overmind.actions.toolbox.toggleBrushSelectionMode();\n    // switch to Dotted Freehand tool after selection\n    overmind.actions.toolbox.setSelectedDrawingTool('dottedFreehand');\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx } = params;\n    const mousePos = getMousePos(ctx.canvas, event);\n    overmind.actions.tool.brushSelectionStart(mousePos);\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    overmind.actions.tool.brushSelectionStart(null);\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      selection.edgeToEdgeCrosshair(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    selection.box(ctx, start, mousePos);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseUpOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx",["489","490"],"import { Tool, EventHandlerParamsWithEvent } from './Tool';\nimport { getMousePos } from './util/util';\nimport { overmind } from '../index';\nimport { paintingCanvasController } from '../canvas/paintingCanvas/PaintingCanvasController';\n\nexport class ColorSelectorTool implements Tool {\n  public constructor(foregroundColor: boolean) {\n    this.foregroundColor = foregroundColor;\n  }\n  private foregroundColor: boolean;\n\n  public onClick(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n    //const colorIndex = paintingCanvasController.colorIndexer?.getColorIndexForPixel(mousePos);\n    const colorIndex = 1;\n    if (!colorIndex) {\n      return;\n    }\n    if (this.foregroundColor) {\n      overmind.actions.palette.setForegroundColor(colorIndex.toString());\n      overmind.actions.toolbox.toggleForegroundColorSelectionMode();\n    } else {\n      overmind.actions.palette.setBackgroundColor(colorIndex.toString());\n      overmind.actions.toolbox.toggleBackgroundColorSelectionMode();\n    }\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  // No overlay\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx",["491"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  omit,\n  isLeftOrRightMouseButton,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class DottedFreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons) {\n      const mousePos = getMousePos(canvas, event);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts",["492"],"/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx",["493","494","495"],"import { Point, Color } from '../../types';\nimport { Tool, EventHandlerParams, EventHandlerParamsOverlay } from '../Tool';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { overmind } from '../../index';\nimport { paintingCanvasController } from '../../canvas/paintingCanvas/PaintingCanvasController';\n\nexport function colorToRGBString(color: Color): string {\n  return 'rgb(' + color.r + ',' + color.g + ',' + color.b + ')';\n}\n\nexport function getMousePos(\n  canvas: HTMLCanvasElement,\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): Point {\n  const rect = canvas.getBoundingClientRect(), // abs. size of element\n    scaleX = canvas.width / rect.width, // relationship bitmap vs. element for X\n    scaleY = canvas.height / rect.height; // relationship bitmap vs. element for Y\n\n  return {\n    x: Math.floor((event.clientX - rect.left) * scaleX), // scale mouse coordinates after they have\n    y: Math.floor((event.clientY - rect.top) * scaleY), // been adjusted to be relative to element\n  };\n}\n\nexport function pointEquals(point1: Point, point2: Point): boolean {\n  return point1.x === point2.x && point1.y === point2.y;\n}\n\nexport function points8Connected(point1: Point, point2: Point): boolean {\n  return Math.abs(point1.x - point2.x) <= 1 && Math.abs(point1.y - point2.y) <= 1;\n}\n\nexport function clearCanvas(canvas: HTMLCanvasElement, color: Color): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n  ctx.rect(0, 0, canvas.width, canvas.height);\n  const oldFillStyle = ctx.fillStyle;\n  ctx.fillStyle = colorToRGBString(color);\n  ctx.fill();\n  ctx.fillStyle = oldFillStyle;\n}\n\nexport function clearOverlayCanvas(canvas: HTMLCanvasElement): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nexport function getEventHandler(\n  tool: Tool,\n  eventHandlerName:\n    | 'onClick'\n    | 'onContextMenu'\n    | 'onMouseMove'\n    | 'onMouseUp'\n    | 'onMouseDown'\n    | 'onMouseLeave'\n    | 'onMouseEnter',\n  eventHandlerParams: EventHandlerParams\n): (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void {\n  if (hasKey(tool, eventHandlerName)) {\n    return (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): void =>\n      tool[eventHandlerName]!({ event: event, ...eventHandlerParams });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  return (): void => {};\n}\n\nexport function getEventHandlerOverlay(\n  tool: Tool,\n  eventHandlerName:\n    | 'onMouseMoveOverlay'\n    | 'onMouseLeaveOverlay'\n    | 'onMouseEnterOverlay'\n    | 'onMouseUpOverlay'\n    | 'onMouseDownOverlay'\n    | 'onClickOverlay',\n  eventHandlerParams: EventHandlerParamsOverlay\n): (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void {\n  if (hasKey(tool, eventHandlerName)) {\n    return (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): void =>\n      tool[eventHandlerName]!({ event: event, ...eventHandlerParams });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  return (): void => {};\n}\n\nfunction hasKey<O>(obj: O, key: keyof any): key is keyof O {\n  return key in obj;\n}\n\nexport function isRightMouseButton(\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): boolean {\n  return event.button === 2 || event.buttons === 2;\n}\n\nexport function isLeftMouseButton(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): boolean {\n  return event.button === 1 || event.buttons === 1;\n}\n\nexport function isLeftOrRightMouseButton(\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): boolean {\n  return isLeftMouseButton(event) || isRightMouseButton(event);\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/11472273/how-to-edit-pixels-and-remove-white-background-in-a-canvas-image-in-html5-and-ja\nexport function extractBrush(\n  sourceCanvas: HTMLCanvasElement,\n  start: Point,\n  width: number,\n  height: number\n): CustomBrush {\n  const bufferCanvas = document.createElement('canvas');\n\n  bufferCanvas.width = Math.abs(width);\n  bufferCanvas.height = Math.abs(height);\n\n  const bufferCanvasCtx = bufferCanvas.getContext('2d');\n  if (!bufferCanvasCtx) {\n    throw 'Error retrieving Context for buffer Canvas while extracting brush';\n  }\n\n  bufferCanvasCtx.drawImage(\n    sourceCanvas,\n    start.x,\n    start.y,\n    width,\n    height,\n    0,\n    0,\n    bufferCanvas.width,\n    bufferCanvas.height\n  );\n\n  const backgroundColor =\n    overmind.state.palette.backgroundColor.r * 0x00000001 +\n    overmind.state.palette.backgroundColor.g * 0x00000100 +\n    overmind.state.palette.backgroundColor.b * 0x00010000 +\n    255 * 0x01000000;\n\n  const imageData = bufferCanvasCtx.getImageData(0, 0, bufferCanvas.width, bufferCanvas.height);\n  const imageDataBufferTMP = new ArrayBuffer(imageData.data.length);\n  const imageDataClamped8TMP = new Uint8ClampedArray(imageDataBufferTMP);\n  const imageDataUint32TMP = new Uint32Array(imageDataBufferTMP);\n\n  imageDataClamped8TMP.set(imageData.data);\n\n  let n = imageDataUint32TMP.length;\n  while (n--) {\n    if (imageDataUint32TMP[n] === backgroundColor) {\n      imageDataUint32TMP[n] = 0x00000000; // make it transparent\n    }\n  }\n\n  imageData.data.set(imageDataClamped8TMP);\n  bufferCanvasCtx.putImageData(imageData, 0, 0);\n\n  // Extract color index and add tansparency for background color\n\n  const colorIndex = paintingCanvasController.getAreaFromIndex(start.x, start.y, width, height);\n  if (!colorIndex) {\n    throw 'Error retrieving color index for new brush';\n  }\n  const colorIndexWithTransparency = addTransparency(\n    colorIndex,\n    Number(overmind.state.palette.backgroundColorId)\n  );\n\n  // invert y\n\n  const colorIndexInverted = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n  for (let y = 0; y < bufferCanvas.height; y++) {\n    for (let x = 0; x < bufferCanvas.width * 4; x++) {\n      const index = x + y * bufferCanvas.width * 4;\n      const indexOrig = x + (bufferCanvas.height - 1 - y) * (bufferCanvas.width * 4);\n      colorIndexInverted[index] = colorIndexWithTransparency[indexOrig];\n    }\n  }\n\n  return new CustomBrush(bufferCanvas.toDataURL(), colorIndexInverted);\n}\n\nexport function addTransparency(texture: Uint8Array, transparentColorIndex: number): Uint8Array {\n  return texture.map((item) => (item === transparentColorIndex ? 0 : item));\n}\n\ninterface Omit {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  <T extends object, K extends [...(keyof T)[]]>(obj: T, ...keys: K): {\n    [K2 in Exclude<keyof T, K[number]>]: T[K2];\n  };\n}\n\nexport const omit: Omit = (obj, ...keys) => {\n  const ret = {} as {\n    [K in keyof typeof obj]: typeof obj[K];\n  };\n  let key: keyof typeof obj;\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n};\n","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts",["496","497"],"// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts",["498"],"import { GeometricIndexer } from './indexers/GeometricIndexer';\nimport { DrawImageIndexer } from './indexers/DrawImageIndexer';\nimport { CustomBrush } from '../brush/CustomBrush';\nimport { overmind } from '../index';\nimport { Line, Point } from '../types';\nimport { visualiseTexture } from './util';\n\nexport class ColorIndexer {\n  private gl: WebGLRenderingContext;\n  private fb: WebGLFramebuffer | null = null;\n  private geometricIndexer: GeometricIndexer;\n  private drawImageIndexer: DrawImageIndexer;\n\n  constructor(gl: WebGLRenderingContext) {\n    //this.gl = this.createIndexerGLContext(0, 0, 0);\n    this.gl = gl;\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n    this.resetIndex();\n  }\n\n  /*   private createIndexerGLContext(\n    width: number,\n    height: number,\n    backgroundColorId: number\n  ): WebGLRenderingContext {\n    // init a webgl context for a canvas element outside the DOM\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const gl = canvas.getContext('webgl', {\n      preserveDrawingBuffer: true,\n      antialias: false,\n    });\n\n    if (!gl) {\n      alert('Sorry, ReDPaint requires WebGL support:(');\n      throw 'Sorry, ReDPaint requires WebGL support';\n    }\n    return gl;\n  } */\n\n  /*   init(): void {\n    const width = overmind.state.canvas.resolution.width;\n    const height = overmind.state.canvas.resolution.height;\n    const backgroundColorId = Number(overmind.state.palette.backgroundColorId);\n    console.log(`ColorIndexer init, width=${width}, heigth=${height}`);\n    this.gl = this.createIndexerGLContext(width, height, backgroundColorId);\n\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n  } */\n\n  fillRect(start: Point, end: Point, colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexFillRect(start, end, colorIndex);\n  }\n\n  points(points: Point[], colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexPoints(points, colorIndex);\n  }\n\n  lines(lines: Line[], colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexLines(lines, colorIndex);\n  }\n\n  drawImage(x: number, y: number, brush: CustomBrush): void {\n    this.drawImageIndexer.indexDrawImage(x, y, brush);\n  }\n\n  getIndexAsCanvas(): HTMLCanvasElement | OffscreenCanvas {\n    return this.gl.canvas;\n  }\n\n  getIndex(): Uint8Array {\n    const pixels = new Uint8Array(this.gl.drawingBufferHeight * this.gl.drawingBufferWidth * 4);\n    this.gl.readPixels(\n      0,\n      0,\n      this.gl.drawingBufferWidth,\n      this.gl.drawingBufferHeight,\n      this.gl.RGBA,\n      this.gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  resetIndex(): void {\n    const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    // initialize the color index matrix with the background color\n    const backgroundColor = Number(overmind.state.palette.backgroundColorId);\n    const data = new Uint8Array(gl.drawingBufferHeight * gl.drawingBufferWidth * 4).fill(\n      backgroundColor\n    );\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      data\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    this.fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n  }\n\n  setIndex(index: Uint8Array | null): void {\n    /* if (!index) {\n      return;\n    }\n\n    const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      index\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n    */\n  }\n\n  getAreaFromIndex(\n    x: number, // canvas coord (origin upper left corner)\n    y: number, // canvas coord (origin upper left corner)\n    width: number, // canvas coord, can be negative\n    height: number // canvas coord, can be negative\n  ): Uint8Array | undefined {\n    const gl = this.gl;\n\n    // for readPixels we need to define the area with:\n    // - lower left corner of the area and\n    // - width and height as positive integers\n    // Texture coordinates\n\n    let rectLowerLeftX: number;\n    let rectLowerLeftY: number;\n\n    if (width < 0) {\n      rectLowerLeftX = x - Math.abs(width);\n    } else {\n      rectLowerLeftX = x;\n    }\n\n    if (height < 0) {\n      rectLowerLeftY = gl.drawingBufferHeight - y;\n    } else {\n      rectLowerLeftY = gl.drawingBufferHeight - y - Math.abs(height);\n    }\n\n    const pixels = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n    console.log('canvas: x:' + x + ' y: ' + y + ' w: ' + width + ' h: ' + height);\n    console.log(\n      'texture: x:' +\n        rectLowerLeftX +\n        ' y: ' +\n        rectLowerLeftY +\n        ' w: ' +\n        Math.abs(width) +\n        ' h: ' +\n        Math.abs(height)\n    );\n    console.log('gl.drawingBufferHeight: ' + gl.drawingBufferHeight);\n    gl.readPixels(\n      rectLowerLeftX,\n      rectLowerLeftY,\n      Math.abs(width),\n      Math.abs(height),\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  getColorIndexForPixel(point: Point): number | undefined {\n    const colorIndex = this.getAreaFromIndex(point.x, point.y, 1, 1);\n    return colorIndex?.[0];\n  }\n\n  // testing, debugging purposes only\n  visualiseIndex(): void {\n    const index = this.getIndex();\n    const width = this.gl.drawingBufferWidth;\n    visualiseTexture(index, width);\n  }\n}\n\n//export const colorIndexer = new ColorIndexer();\n","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts",["499"],"import { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../util';\n\nexport class GeometricIndexer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private currentColorIndex = 0;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public indexPoints(points: Point[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public indexLines(lines: Line[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  public indexFillRect(start: Point, end: Point, colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const width = end.x - start.x;\n    const height = end.y - start.y;\n\n    if (width === 1 && height === 1) {\n      this.fillRectPoint(start);\n    } else {\n      this.fillRectQuad(start, end);\n    }\n  }\n\n  private fillRectPoint(point: Point): void {\n    const gl = this.gl;\n\n    const shiftedPoint = shiftPoint(point);\n\n    const vertices = new Float32Array(2);\n    vertices[0] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n    vertices[1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, 1);\n  }\n\n  private fillRectQuad(start: Point, end: Point): void {\n    const gl = this.gl;\n\n    const shiftedStart = shiftPoint(start);\n    const shiftedEnd = shiftPoint(end);\n    const xLeft = canvasToWebGLCoordX(gl, shiftedStart.x);\n    const xRight = canvasToWebGLCoordX(gl, shiftedEnd.x);\n    const yTop = canvasToWebGLCoordInvert(gl, shiftedStart.y);\n    const yBottom = canvasToWebGLCoordInvert(gl, shiftedEnd.y);\n\n    const vertices = new Float32Array(8);\n    vertices[0] = xLeft;\n    vertices[1] = yTop;\n\n    vertices[2] = xLeft;\n    vertices[3] = yBottom;\n\n    vertices[4] = xRight;\n    vertices[5] = yTop;\n\n    vertices[6] = xRight;\n    vertices[7] = yBottom;\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform float u_colorIndex;\n\n    void main () {\n      gl_FragColor = vec4(u_colorIndex/255.0, 0.0, 0.0, 1.0);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile to program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n    console.log('Program ready (GeometricIndexer)');\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts",["500","501"],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts",["502"],"/* eslint-disable max-len */\nimport { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../../colorIndex/util';\nimport { overmind } from '../..';\n\nexport class OverlayGeometricRenderer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private currentColorIndex = 0;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public renderPoints(points: Point[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public renderLines(lines: Line[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  private updateColor(colorIndex: number) {\n    if (colorIndex == this.currentColorIndex) {\n      return;\n    }\n\n    if (!this.program) {\n      return;\n    }\n    const gl = this.gl;\n\n    console.log('updating color uniform');\n    this.currentColorIndex = colorIndex;\n    const color = overmind.state.palette.paletteArray[colorIndex - 1];\n    const u_color = gl.getUniformLocation(this.program, 'u_color');\n    gl.uniform3f(u_color, color.r, color.g, color.b);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform vec3 u_color;\n\n    void main () {\n      gl_FragColor = vec4(u_color.x/255.0, u_color.y/255.0, u_color.z/255.0, 1.0);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile to program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n    console.log('Program ready (FillRectIndexer)');\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricIndexer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/PaintingCanvasController.ts",["503"],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageIndexer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayCanvasController.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/program/OverlayGeometricRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayMainCanvasRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/util/util.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/ZoomCanvasRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/ColorIndexer.ts",["504"],"import { GeometricIndexer } from './program/GeometricIndexer';\nimport { DrawImageIndexer } from './program/DrawImageIndexer';\nimport { Line, Point } from '../../types';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { visualiseTexture } from '../../colorIndex/util';\nimport { LineV } from '../../domain/LineV';\nimport { LineH } from '../../domain/LineH';\n\ntype GLBuffers = {\n  colorIndexFramebuffer: WebGLFramebuffer;\n  vertexBuffer: WebGLBuffer;\n  textureCoordBuffer: WebGLBuffer;\n};\n\nexport class ColorIndexer {\n  private gl: WebGLRenderingContext;\n  private colorIndexFramebuffer: WebGLFramebuffer;\n  private geometricIndexer: GeometricIndexer;\n  private drawImageIndexer: DrawImageIndexer;\n\n  constructor(gl: WebGLRenderingContext, buffers: GLBuffers) {\n    this.gl = gl;\n    this.colorIndexFramebuffer = buffers.colorIndexFramebuffer;\n\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(gl, buffers.colorIndexFramebuffer);\n    this.drawImageIndexer = new DrawImageIndexer(gl, buffers);\n  }\n\n  points(points: Point[], colorIndex: number): void {\n    this.geometricIndexer.indexPoints(points, colorIndex);\n  }\n\n  lines(lines: (LineH | LineV)[], colorIndex: number): void {\n    this.geometricIndexer.indexLines(lines, colorIndex);\n  }\n\n  quad(start: Point, end: Point, colorIndex: number): void {\n    this.geometricIndexer.indexQuad(start, end, colorIndex);\n  }\n\n  drawImage(points: Point[], brush: CustomBrush): void {\n    this.drawImageIndexer.indexDrawImage(points, brush);\n  }\n\n  getIndex(): Uint8Array {\n    const gl = this.gl;\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.colorIndexFramebuffer);\n\n    const pixels = new Uint8Array(gl.drawingBufferHeight * gl.drawingBufferWidth * 4);\n    gl.readPixels(\n      0,\n      0,\n      gl.drawingBufferWidth,\n      gl.drawingBufferHeight,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return pixels;\n  }\n\n  getAreaFromIndex(\n    x: number, // canvas coord (origin upper left corner)\n    y: number, // canvas coord (origin upper left corner)\n    width: number, // canvas coord, can be negative\n    height: number // canvas coord, can be negative\n  ): Uint8Array | undefined {\n    const gl = this.gl;\n\n    // for readPixels we need to define the area with:\n    // - lower left corner of the area and\n    // - width and height as positive integers\n    // Texture coordinates\n\n    let rectLowerLeftX: number;\n    let rectLowerLeftY: number;\n\n    if (width < 0) {\n      rectLowerLeftX = x - Math.abs(width);\n    } else {\n      rectLowerLeftX = x;\n    }\n\n    if (height < 0) {\n      rectLowerLeftY = gl.drawingBufferHeight - y;\n    } else {\n      rectLowerLeftY = gl.drawingBufferHeight - y - Math.abs(height);\n    }\n\n    const pixels = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n    console.log('canvas: x:' + x + ' y: ' + y + ' w: ' + width + ' h: ' + height);\n    console.log(\n      'texture: x:' +\n        rectLowerLeftX +\n        ' y: ' +\n        rectLowerLeftY +\n        ' w: ' +\n        Math.abs(width) +\n        ' h: ' +\n        Math.abs(height)\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.colorIndexFramebuffer);\n    gl.readPixels(\n      rectLowerLeftX,\n      y,\n      Math.abs(width),\n      Math.abs(height),\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return pixels;\n  }\n\n  // testing, debugging purposes only\n  visualiseIndex(): void {\n    const gl = this.gl;\n\n    const index = this.getIndex();\n    const width = gl.drawingBufferWidth;\n    visualiseTexture(index, width);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/MainCanvasRenderer.ts",["505"],"/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/program/OverlayDrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/domain/LineV.ts",[],"/Users/jani/Code/Web/dxpaint/src/domain/LineH.ts",[],"/Users/jani/Code/Web/dxpaint/src/domain/Line.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/util/webglUtil.ts",[],{"ruleId":"506","severity":1,"message":"507","line":55,"column":10,"nodeType":"508","messageId":"509","endLine":55,"endColumn":20},{"ruleId":"506","severity":1,"message":"507","line":64,"column":10,"nodeType":"508","messageId":"509","endLine":64,"endColumn":27},{"ruleId":"510","severity":1,"message":"511","line":3,"column":10,"nodeType":"512","messageId":"513","endLine":3,"endColumn":19},{"ruleId":"510","severity":1,"message":"514","line":5,"column":3,"nodeType":"512","messageId":"513","endLine":5,"endColumn":7},{"ruleId":"510","severity":1,"message":"515","line":6,"column":3,"nodeType":"512","messageId":"513","endLine":6,"endColumn":15},{"ruleId":"510","severity":1,"message":"516","line":7,"column":3,"nodeType":"512","messageId":"513","endLine":7,"endColumn":13},{"ruleId":"510","severity":1,"message":"517","line":8,"column":3,"nodeType":"512","messageId":"513","endLine":8,"endColumn":17},{"ruleId":"510","severity":1,"message":"518","line":10,"column":3,"nodeType":"512","messageId":"513","endLine":10,"endColumn":8},{"ruleId":"510","severity":1,"message":"519","line":24,"column":10,"nodeType":"512","messageId":"513","endLine":24,"endColumn":15},{"ruleId":"510","severity":1,"message":"520","line":25,"column":10,"nodeType":"512","messageId":"513","endLine":25,"endColumn":15},{"ruleId":"510","severity":1,"message":"521","line":3,"column":10,"nodeType":"512","messageId":"513","endLine":3,"endColumn":14},{"ruleId":"510","severity":1,"message":"522","line":9,"column":3,"nodeType":"512","messageId":"513","endLine":9,"endColumn":21},{"ruleId":"510","severity":1,"message":"523","line":29,"column":17,"nodeType":"512","messageId":"513","endLine":29,"endColumn":43},{"ruleId":"510","severity":1,"message":"524","line":122,"column":14,"nodeType":"512","messageId":"513","endLine":122,"endColumn":20},{"ruleId":"510","severity":1,"message":"524","line":132,"column":14,"nodeType":"512","messageId":"513","endLine":132,"endColumn":20},{"ruleId":"510","severity":1,"message":"523","line":27,"column":17,"nodeType":"512","messageId":"513","endLine":27,"endColumn":43},{"ruleId":"506","severity":1,"message":"507","line":22,"column":26,"nodeType":"508","messageId":"509","endLine":22,"endColumn":39},{"ruleId":"510","severity":1,"message":"514","line":4,"column":3,"nodeType":"512","messageId":"513","endLine":4,"endColumn":7},{"ruleId":"510","severity":1,"message":"515","line":5,"column":3,"nodeType":"512","messageId":"513","endLine":5,"endColumn":15},{"ruleId":"510","severity":1,"message":"517","line":6,"column":3,"nodeType":"512","messageId":"513","endLine":6,"endColumn":17},{"ruleId":"510","severity":1,"message":"525","line":7,"column":3,"nodeType":"512","messageId":"513","endLine":7,"endColumn":15},{"ruleId":"510","severity":1,"message":"516","line":8,"column":3,"nodeType":"512","messageId":"513","endLine":8,"endColumn":13},{"ruleId":"510","severity":1,"message":"518","line":9,"column":3,"nodeType":"512","messageId":"513","endLine":9,"endColumn":8},{"ruleId":"510","severity":1,"message":"526","line":22,"column":10,"nodeType":"512","messageId":"513","endLine":22,"endColumn":21},{"ruleId":"510","severity":1,"message":"523","line":31,"column":17,"nodeType":"512","messageId":"513","endLine":31,"endColumn":43},{"ruleId":"510","severity":1,"message":"523","line":30,"column":17,"nodeType":"512","messageId":"513","endLine":30,"endColumn":43},{"ruleId":"510","severity":1,"message":"523","line":34,"column":17,"nodeType":"512","messageId":"513","endLine":34,"endColumn":43},{"ruleId":"510","severity":1,"message":"527","line":5,"column":10,"nodeType":"512","messageId":"513","endLine":5,"endColumn":22},{"ruleId":"510","severity":1,"message":"528","line":51,"column":13,"nodeType":"512","messageId":"513","endLine":51,"endColumn":23},{"ruleId":"510","severity":1,"message":"529","line":19,"column":11,"nodeType":"512","messageId":"513","endLine":19,"endColumn":21},{"ruleId":"510","severity":1,"message":"530","line":7,"column":52,"nodeType":"512","messageId":"513","endLine":7,"endColumn":57},{"ruleId":"510","severity":1,"message":"530","line":45,"column":37,"nodeType":"512","messageId":"513","endLine":45,"endColumn":42},{"ruleId":"510","severity":1,"message":"523","line":56,"column":23,"nodeType":"512","messageId":"513","endLine":56,"endColumn":58},{"ruleId":"510","severity":1,"message":"531","line":4,"column":10,"nodeType":"512","messageId":"513","endLine":4,"endColumn":34},{"ruleId":"510","severity":1,"message":"532","line":17,"column":11,"nodeType":"512","messageId":"513","endLine":17,"endColumn":19},{"ruleId":"510","severity":1,"message":"523","line":25,"column":17,"nodeType":"512","messageId":"513","endLine":25,"endColumn":43},{"ruleId":"510","severity":1,"message":"531","line":2,"column":10,"nodeType":"512","messageId":"513","endLine":2,"endColumn":34},{"ruleId":"506","severity":1,"message":"507","line":67,"column":7,"nodeType":"508","messageId":"509","endLine":67,"endColumn":30,"suggestions":"533"},{"ruleId":"506","severity":1,"message":"507","line":86,"column":7,"nodeType":"508","messageId":"509","endLine":86,"endColumn":30,"suggestions":"534"},{"ruleId":"535","severity":1,"message":"536","line":92,"column":39,"nodeType":"537","messageId":"538","endLine":92,"endColumn":42,"suggestions":"539"},{"ruleId":"540","severity":1,"message":"541","line":26,"column":8,"nodeType":"542","messageId":"543","endLine":26,"endColumn":42},{"ruleId":"540","severity":1,"message":"541","line":133,"column":8,"nodeType":"542","messageId":"543","endLine":133,"endColumn":29},{"ruleId":"510","severity":1,"message":"544","line":144,"column":12,"nodeType":"512","messageId":"513","endLine":144,"endColumn":36},{"ruleId":"510","severity":1,"message":"545","line":5,"column":3,"nodeType":"512","messageId":"513","endLine":5,"endColumn":22},{"ruleId":"510","severity":1,"message":"545","line":6,"column":3,"nodeType":"512","messageId":"513","endLine":6,"endColumn":22},{"ruleId":"510","severity":1,"message":"531","line":10,"column":10,"nodeType":"512","messageId":"513","endLine":10,"endColumn":34},{"ruleId":"510","severity":1,"message":"545","line":6,"column":3,"nodeType":"512","messageId":"513","endLine":6,"endColumn":22},{"ruleId":"510","severity":1,"message":"521","line":3,"column":10,"nodeType":"512","messageId":"513","endLine":3,"endColumn":14},{"ruleId":"510","severity":1,"message":"521","line":3,"column":10,"nodeType":"512","messageId":"513","endLine":3,"endColumn":14},{"ruleId":"510","severity":1,"message":"521","line":3,"column":10,"nodeType":"512","messageId":"513","endLine":3,"endColumn":14},"@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","@typescript-eslint/no-unused-vars","'drawImage' is defined but never used.","Identifier","unusedVar","'line' is defined but never used.","'unfilledRect' is defined but never used.","'filledRect' is defined but never used.","'unfilledCircle' is defined but never used.","'curve' is defined but never used.","'LineV' is defined but never used.","'LineH' is defined but never used.","'Line' is defined but never used.","'clearOverlayCanvas' is defined but never used.","'params' is defined but never used.","'canvas' is assigned a value but never used.","'filledCircle' is defined but never used.","'pointEquals' is defined but never used.","'blobToCanvas' is defined but never used.","'colorIndex' is assigned a value but never used.","'mainCanvas' is assigned a value but never used.","'state' is defined but never used.","'paintingCanvasController' is defined but never used.","'mousePos' is assigned a value but never used.",["546"],["547"],"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["548","549"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","'index' is defined but never used.","'canvasToWebGLCoordY' is defined but never used.",{"messageId":"550","fix":"551","desc":"552"},{"messageId":"550","fix":"553","desc":"552"},{"messageId":"554","fix":"555","desc":"556"},{"messageId":"557","fix":"558","desc":"559"},"suggestOptionalChain",{"range":"560","text":"561"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"562","text":"561"},"suggestUnknown",{"range":"563","text":"564"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"563","text":"565"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",[2289,2290],"?.",[2928,2929],[3109,3112],"unknown","never"]