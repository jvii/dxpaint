[{"/Users/jani/Code/Web/dxpaint/src/index.tsx":"1","/Users/jani/Code/Web/dxpaint/src/components/App.tsx":"2","/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx":"3","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx":"4","/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx":"5","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx":"6","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts":"7","/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts":"8","/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts":"9","/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts":"10","/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx":"11","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx":"12","/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx":"13","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts":"14","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts":"15","/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts":"16","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts":"17","/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts":"18","/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts":"19","/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts":"20","/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx":"21","/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx":"22","/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx":"23","/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx":"24","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx":"25","/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx":"26","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts":"27","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx":"28","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx":"29","/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx":"30","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts":"31","/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts":"32","/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts":"33","/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts":"34","/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx":"35","/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx":"36","/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx":"37","/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx":"38","/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx":"39","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx":"40","/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx":"41","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx":"42","/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx":"43","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx":"44","/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx":"45","/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx":"46","/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx":"47","/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx":"48","/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts":"49","/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts":"50","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts":"51","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx":"52","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx":"53","/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts":"54","/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts":"55","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx":"56","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx":"57","/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx":"58","/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx":"59","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts":"60","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts":"61","/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx":"62","/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx":"63","/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts":"64","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts":"65","/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx":"66","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts":"67","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts":"68","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx":"69","/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx":"70","/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts":"71","/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts":"72","/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts":"73","/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx":"74","/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx":"75","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts":"76","/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts":"77","/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts":"78","/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx":"79","/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts":"80","/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx":"81","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts":"82","/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts":"83","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts":"84","/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts":"85","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts":"86","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts":"87","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts":"88","/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts":"89","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricIndexer.ts":"90","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageRenderer.ts":"91","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricRenderer.ts":"92","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/PaintingCanvasController.ts":"93","/Users/jani/Code/Web/dxpaint/src/canvas/util.ts":"94","/Users/jani/Code/Web/dxpaint/src/canvas/webglUtil.ts":"95","/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageIndexer.ts":"96","/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayCanvasController.ts":"97"},{"size":758,"mtime":1581006660054,"results":"98","hashOfConfig":"99"},{"size":1647,"mtime":1610123744119,"results":"100","hashOfConfig":"99"},{"size":2303,"mtime":1587397395180,"results":"101","hashOfConfig":"99"},{"size":1650,"mtime":1587397383935,"results":"102","hashOfConfig":"99"},{"size":4292,"mtime":1588883165180,"results":"103","hashOfConfig":"99"},{"size":1341,"mtime":1609964713351,"results":"104","hashOfConfig":"99"},{"size":99,"mtime":1570358386366,"results":"105","hashOfConfig":"99"},{"size":99,"mtime":1589653071467,"results":"106","hashOfConfig":"99"},{"size":99,"mtime":1581162181250,"results":"107","hashOfConfig":"99"},{"size":407,"mtime":1613232457299,"results":"108","hashOfConfig":"99"},{"size":5437,"mtime":1617126089378,"results":"109","hashOfConfig":"99"},{"size":712,"mtime":1586637521430,"results":"110","hashOfConfig":"99"},{"size":6971,"mtime":1617431056453,"results":"111","hashOfConfig":"99"},{"size":103,"mtime":1589645340777,"results":"112","hashOfConfig":"99"},{"size":238,"mtime":1589698799652,"results":"113","hashOfConfig":"99"},{"size":994,"mtime":1610288900130,"results":"114","hashOfConfig":"99"},{"size":2307,"mtime":1587665133808,"results":"115","hashOfConfig":"99"},{"size":3939,"mtime":1606591580738,"results":"116","hashOfConfig":"99"},{"size":775,"mtime":1598628605933,"results":"117","hashOfConfig":"99"},{"size":16061,"mtime":1617344388476,"results":"118","hashOfConfig":"99"},{"size":3796,"mtime":1617126089307,"results":"119","hashOfConfig":"99"},{"size":2427,"mtime":1598195635333,"results":"120","hashOfConfig":"99"},{"size":5449,"mtime":1598418063310,"results":"121","hashOfConfig":"99"},{"size":3330,"mtime":1617089360353,"results":"122","hashOfConfig":"99"},{"size":3137,"mtime":1614154844644,"results":"123","hashOfConfig":"99"},{"size":749,"mtime":1606592951751,"results":"124","hashOfConfig":"99"},{"size":1069,"mtime":1609948473281,"results":"125","hashOfConfig":"99"},{"size":419,"mtime":1586636737515,"results":"126","hashOfConfig":"99"},{"size":1292,"mtime":1615622215367,"results":"127","hashOfConfig":"99"},{"size":448,"mtime":1606592971846,"results":"128","hashOfConfig":"99"},{"size":990,"mtime":1606591610390,"results":"129","hashOfConfig":"99"},{"size":163,"mtime":1616686264476,"results":"130","hashOfConfig":"99"},{"size":787,"mtime":1610395467992,"results":"131","hashOfConfig":"99"},{"size":3492,"mtime":1598088214899,"results":"132","hashOfConfig":"99"},{"size":3449,"mtime":1617088355894,"results":"133","hashOfConfig":"99"},{"size":3020,"mtime":1617126076645,"results":"134","hashOfConfig":"99"},{"size":1686,"mtime":1596966551515,"results":"135","hashOfConfig":"99"},{"size":3062,"mtime":1598418004456,"results":"136","hashOfConfig":"99"},{"size":4424,"mtime":1598418176200,"results":"137","hashOfConfig":"99"},{"size":620,"mtime":1609948514564,"results":"138","hashOfConfig":"99"},{"size":1542,"mtime":1616932868894,"results":"139","hashOfConfig":"99"},{"size":1328,"mtime":1576359001814,"results":"140","hashOfConfig":"99"},{"size":3226,"mtime":1613738313456,"results":"141","hashOfConfig":"99"},{"size":849,"mtime":1582737330219,"results":"142","hashOfConfig":"99"},{"size":1947,"mtime":1613737455235,"results":"143","hashOfConfig":"99"},{"size":794,"mtime":1589698776952,"results":"144","hashOfConfig":"99"},{"size":5255,"mtime":1613737486628,"results":"145","hashOfConfig":"99"},{"size":1298,"mtime":1589699509988,"results":"146","hashOfConfig":"99"},{"size":99,"mtime":1570358390587,"results":"147","hashOfConfig":"99"},{"size":99,"mtime":1570358382606,"results":"148","hashOfConfig":"99"},{"size":99,"mtime":1570358454848,"results":"149","hashOfConfig":"99"},{"size":479,"mtime":1586285629987,"results":"150","hashOfConfig":"99"},{"size":691,"mtime":1582737314794,"results":"151","hashOfConfig":"99"},{"size":197,"mtime":1589653419630,"results":"152","hashOfConfig":"99"},{"size":1538,"mtime":1613232457299,"results":"153","hashOfConfig":"99"},{"size":2633,"mtime":1596966551507,"results":"154","hashOfConfig":"99"},{"size":4696,"mtime":1617126089378,"results":"155","hashOfConfig":"99"},{"size":1250,"mtime":1617126089377,"results":"156","hashOfConfig":"99"},{"size":2017,"mtime":1597691407920,"results":"157","hashOfConfig":"99"},{"size":99,"mtime":1589645298846,"results":"158","hashOfConfig":"99"},{"size":1651,"mtime":1617126089306,"results":"159","hashOfConfig":"99"},{"size":3834,"mtime":1617126089378,"results":"160","hashOfConfig":"99"},{"size":3797,"mtime":1596966551513,"results":"161","hashOfConfig":"99"},{"size":99,"mtime":1570358463891,"results":"162","hashOfConfig":"99"},{"size":3476,"mtime":1606591793814,"results":"163","hashOfConfig":"99"},{"size":2892,"mtime":1598418027518,"results":"164","hashOfConfig":"99"},{"size":221,"mtime":1609964687396,"results":"165","hashOfConfig":"99"},{"size":94,"mtime":1609948309696,"results":"166","hashOfConfig":"99"},{"size":1140,"mtime":1610122119190,"results":"167","hashOfConfig":"99"},{"size":2782,"mtime":1610122387748,"results":"168","hashOfConfig":"99"},{"size":3111,"mtime":1613738274657,"results":"169","hashOfConfig":"99"},{"size":1841,"mtime":1615576399763,"results":"170","hashOfConfig":"99"},{"size":1244,"mtime":1616930149618,"results":"171","hashOfConfig":"99"},{"size":3361,"mtime":1610827576318,"results":"172","hashOfConfig":"99"},{"size":6903,"mtime":1617372292669,"results":"173","hashOfConfig":"99"},{"size":99,"mtime":1609948228471,"results":"174","hashOfConfig":"99"},{"size":129,"mtime":1589653235884,"results":"175","hashOfConfig":"99"},{"size":424,"mtime":1611407191206,"results":"176","hashOfConfig":"99"},{"size":758,"mtime":1616082227415,"results":"177","hashOfConfig":"99"},{"size":5183,"mtime":1615012131754,"results":"178","hashOfConfig":"99"},{"size":4028,"mtime":1584903623805,"results":"179","hashOfConfig":"99"},{"size":6009,"mtime":1613307455776,"results":"180","hashOfConfig":"99"},{"size":7497,"mtime":1616689325520,"results":"181","hashOfConfig":"99"},{"size":6619,"mtime":1616699868078,"results":"182","hashOfConfig":"99"},{"size":3560,"mtime":1616699702251,"results":"183","hashOfConfig":"99"},{"size":3927,"mtime":1616828226913,"results":"184","hashOfConfig":"99"},{"size":6718,"mtime":1617125954596,"results":"185","hashOfConfig":"99"},{"size":4844,"mtime":1615909450457,"results":"186","hashOfConfig":"99"},{"size":1782,"mtime":1616930826393,"results":"187","hashOfConfig":"99"},{"size":5481,"mtime":1617126924752,"results":"188","hashOfConfig":"99"},{"size":2080,"mtime":1617126966056,"results":"189","hashOfConfig":"99"},{"size":2755,"mtime":1617126994226,"results":"190","hashOfConfig":"99"},{"size":10542,"mtime":1617370892780,"results":"191","hashOfConfig":"99"},{"size":1841,"mtime":1617089244887,"results":"192","hashOfConfig":"99"},{"size":1587,"mtime":1617126819337,"results":"193","hashOfConfig":"99"},{"size":6705,"mtime":1617358535399,"results":"194","hashOfConfig":"99"},{"size":2571,"mtime":1617088403315,"results":"195","hashOfConfig":"99"},{"filePath":"196","messages":"197","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},"1plr3f1",{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"203"},{"filePath":"204","messages":"205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"210"},{"filePath":"211","messages":"212","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"217","messages":"218","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"219","messages":"220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"221","messages":"222","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"223","usedDeprecatedRules":"198"},{"filePath":"224","messages":"225","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"226","messages":"227","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"228","messages":"229","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"232","messages":"233","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"234","messages":"235","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"238","messages":"239","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"240","messages":"241","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"242","messages":"243","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"244","usedDeprecatedRules":"245"},{"filePath":"246","messages":"247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"248","messages":"249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"252","usedDeprecatedRules":"198"},{"filePath":"253","messages":"254","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"255","messages":"256","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"257","usedDeprecatedRules":"198"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"264","messages":"265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"268","messages":"269","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"270","messages":"271","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"274","messages":"275","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"276","messages":"277","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"278","messages":"279","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"280"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"283","usedDeprecatedRules":"284"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"287","usedDeprecatedRules":"245"},{"filePath":"288","messages":"289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"210"},{"filePath":"292","messages":"293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"294","messages":"295","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"296","usedDeprecatedRules":"280"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"303","messages":"304","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"305","messages":"306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"307","messages":"308","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"309","messages":"310","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"311"},{"filePath":"312","messages":"313","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"314","messages":"315","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"316","messages":"317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"322","usedDeprecatedRules":"213"},{"filePath":"323","messages":"324","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"325","usedDeprecatedRules":"245"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"328","messages":"329","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"330","messages":"331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"332","messages":"333","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"334","messages":"335","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"336","messages":"337","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"338","messages":"339","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"340","messages":"341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"342","messages":"343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"344","messages":"345","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"346","usedDeprecatedRules":"213"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"210"},{"filePath":"351","messages":"352","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"353","messages":"354","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"355","messages":"356","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"357","messages":"358","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"359","messages":"360","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"361","messages":"362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"210"},{"filePath":"363","messages":"364","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"365","messages":"366","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"367","messages":"368","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"369","messages":"370","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"216"},{"filePath":"371","messages":"372","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"373","messages":"374","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"375","usedDeprecatedRules":"216"},{"filePath":"376","messages":"377","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"245"},{"filePath":"378","messages":"379","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"380"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"383","usedDeprecatedRules":"210"},{"filePath":"384","messages":"385","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"386","usedDeprecatedRules":"380"},{"filePath":"387","messages":"388","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"389","messages":"390","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"391","messages":"392","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"393","messages":"394","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"395"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"398","messages":"399","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"400","messages":"401","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"402","messages":"403","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"404"},{"filePath":"405","messages":"406","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"407"},{"filePath":"408","messages":"409","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"198"},{"filePath":"410","messages":"411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"412","messages":"413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"414","messages":"415","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/jani/Code/Web/dxpaint/src/index.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/App.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx",["416","417"],"import React, { useEffect, useRef } from 'react';\nimport { CanvasStateAction } from './CanvasState';\nimport { useInitTool, useUndo, useFillStyle } from './hooks';\nimport { useOvermind } from '../../overmind';\nimport { getEventHandler, getEventHandlerOverlay } from '../../tools/util/util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\nimport './Canvas.css';\nimport { paintingCanvasController } from '../../canvas/paintingCanvas/PaintingCanvasController';\nimport { overlayCanvasController } from '../../canvas/overlayCanvas/OverlayCanvasController';\n\ninterface Props {\n  canvasDispatch: React.Dispatch<CanvasStateAction>;\n  isZoomCanvas: boolean;\n  zoomFactor?: number;\n}\n\nexport function Canvas({\n  canvasDispatch,\n  isZoomCanvas,\n  zoomFactor = 1,\n}: Props): JSX.Element | null {\n  console.log('render ' + (isZoomCanvas ? 'ZoomCanvas' : 'MainCanvas'));\n  const canvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const paintingCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlay2CanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n\n  useEffect((): void => {\n    canvasDispatch({\n      type: isZoomCanvas ? 'setZoomCanvas' : 'setMainCanvas',\n      elements: { canvas: canvasRef.current, overlay: overlayCanvasRef.current },\n    });\n    if (isZoomCanvas) {\n      paintingCanvasController.attachZoomCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachZoomCanvas(overlay2CanvasRef.current);\n    } else {\n      paintingCanvasController.attachMainCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachMainCanvas(overlay2CanvasRef.current);\n    }\n  }, []);\n\n  const canvasCtx = canvasRef.current.getContext('2d', {\n    alpha: false,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const overlayCanvasCtx = overlayCanvasRef.current.getContext('2d', {\n    alpha: true,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const { state, actions } = useOvermind();\n\n  const eventHandlerParams: EventHandlerParams = {\n    ctx: canvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setCanvasModified(isZoomCanvas);\n    },\n    undoPoint: (): void => {\n      actions.undo.setUndoPoint(canvasRef.current);\n    },\n  };\n  const eventHandlerParamsOverlay: EventHandlerParamsOverlay = {\n    ctx: overlayCanvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setOverlayCanvasModified(isZoomCanvas);\n    },\n  };\n\n  useUndo(canvasRef.current);\n  useInitTool(eventHandlerParams, eventHandlerParamsOverlay, isZoomCanvas);\n\n  useFillStyle(canvasCtx);\n  useFillStyle(overlayCanvasCtx);\n\n  if (!canvasCtx || !overlayCanvasCtx) {\n    return null; // no render\n  }\n\n  const tool = state.toolbox.activeTool;\n\n  const CSSZoom = {\n    width: state.canvas.resolution.width * zoomFactor,\n    height: state.canvas.resolution.height * zoomFactor,\n  };\n\n  return (\n    <>\n      <canvas\n        className=\"canvas\"\n        ref={canvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n        onClick={(event): void => {\n          getEventHandler(tool, 'onClick', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onClickOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseDown={(event): void => {\n          getEventHandler(tool, 'onMouseDown', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseDownOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseUp={(event): void => {\n          getEventHandler(tool, 'onMouseUp', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseUpOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseEnter={(event): void => {\n          getEventHandler(tool, 'onMouseEnter', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseEnterOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseLeave={(event): void => {\n          getEventHandler(tool, 'onMouseLeave', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseLeaveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseMove={(event): void => {\n          getEventHandler(tool, 'onMouseMove', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseMoveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onContextMenu={getEventHandler(tool, 'onContextMenu', eventHandlerParams)}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={paintingCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlay2CanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlayCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n    </>\n  );\n}\n","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx",[],"/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx",["418","419"],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx",["420"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n  pointEquals,\n  points8Connected,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\nimport { paintingCanvasController } from '../canvas/paintingCanvas/PaintingCanvasController';\nimport { overlayCanvasController } from '../canvas/overlayCanvas/OverlayCanvasController';\n\nexport class FreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.freeHandToolPrevious(null);\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons && overmind.state.tool.freehandTool.previous) {\n      const mousePos = getMousePos(canvas, event);\n      const start = overmind.state.tool.freehandTool.previous;\n      const end = mousePos;\n      if (pointEquals(start, end)) {\n        return; // this point has already been drawn to canvas\n      }\n      if (points8Connected(start, end)) {\n        brushHistory.current.drawDot(ctx, end, paintingCanvasController);\n      } else {\n        brushHistory.current.drawLine(ctx, start, end, paintingCanvasController);\n      }\n      overmind.actions.tool.freeHandToolPrevious(end);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos, paintingCanvasController);\n    overmind.actions.tool.freeHandToolPrevious(mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    //clearOverlayCanvas(canvas);\n    const mousePos = getMousePos(canvas, event);\n    //brushHistory.current.drawDot(ctx, mousePos);\n    brushHistory.current.drawDot(ctx, mousePos, overlayCanvasController);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx",["421"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class AirbrushTool implements Tool {\n  private timeout = 0;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    overmind.actions.tool.airbrushToolPosition(mousePos);\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx, onPaint } = params;\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const draw = (ctx: CanvasRenderingContext2D, onPaint: Function): void => {\n      for (let i = 50; i--; ) {\n        const angle = getRandomFloat(0, Math.PI * 2);\n        const radius = getRandomFloat(0, 20);\n        if (overmind.state.tool.airbrushTool.position) {\n          brushHistory.current.drawDot(ctx, {\n            x: overmind.state.tool.airbrushTool.position.x + radius * Math.cos(angle),\n            y: overmind.state.tool.airbrushTool.position.y + radius * Math.sin(angle),\n          });\n        }\n      }\n      onPaint();\n      this.timeout = setTimeout(draw, 20, ctx, onPaint);\n    };\n\n    this.prepareToPaint(isRightMouseButton(event));\n    this.timeout = setTimeout(draw, 20, ctx, onPaint);\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    const { event, undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    if (isLeftOrRightMouseButton(event)) {\n      undoPoint();\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n\nfunction getRandomFloat(min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx",["422"],"export class Throttle {\n  private milliSecs: number;\n  private lastFunc: NodeJS.Timeout | null;\n  private lastRan: number | null;\n\n  public constructor(milliSecs: number) {\n    this.milliSecs = milliSecs;\n    this.lastFunc = null;\n    this.lastRan = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  public call(func: Function): void {\n    if (!this.lastRan) {\n      func();\n      this.lastRan = Date.now();\n    } else {\n      if (this.lastFunc) {\n        clearTimeout(this.lastFunc);\n      }\n      this.lastFunc = setTimeout(() => {\n        if (Date.now() - this.lastRan! >= this.milliSecs) {\n          func();\n          this.lastRan = Date.now();\n        }\n      }, this.milliSecs - (Date.now() - this.lastRan));\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx",["423","424","425","426","427"],"/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx",["428"],"/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx",["429"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { Throttle } from './util/Throttle';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class CurveTool implements Tool {\n  private throttle = new Throttle(50);\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.curveToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const endPoint = overmind.state.tool.curveTool.end;\n\n    if (endPoint) {\n      brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos);\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n    } else {\n      overmind.actions.tool.curveToolEnd(mousePos);\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    if (!overmind.state.tool.curveTool.end) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.curveToolStart(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    const endPoint = overmind.state.tool.curveTool.end;\n    if (endPoint) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos);\n      });\n    } else if (isLeftOrRightMouseButton(event)) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawLine(ctx, startPoint, mousePos);\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n",[],"/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx",["430"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  pointEquals,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { Throttle } from './util/Throttle';\nimport { unfilledPolygon } from '../algorithm/shape';\nimport { PixelBrush } from '../brush/PixelBrush';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class PolygonTool implements Tool {\n  private throttle = new Throttle(20);\n  public constructor(filled: boolean) {\n    this.filled = filled;\n  }\n  private filled: boolean;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.polygonToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    // first click (left or right) determines polygon fill color\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      this.prepareToPaint(isRightMouseButton(event));\n      overmind.actions.tool.polygonToolAddVertice(mousePos);\n      return;\n    }\n\n    // complete polygon on right click or if starting point reselected\n    if (\n      isRightMouseButton(event) ||\n      pointEquals(overmind.state.tool.polygonTool.vertices[0], mousePos)\n    ) {\n      if (this.filled) {\n        brushHistory.current.drawFilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      }\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n      return;\n    }\n\n    // otherwise just add new vertice\n    overmind.actions.tool.polygonToolAddVertice(mousePos);\n  }\n\n  // Overlay\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 1) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n    }\n    onPaint();\n  }\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    if (this.filled) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        unfilledPolygon(\n          ctx,\n          new PixelBrush(),\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    } else {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 0) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n      onPaint();\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx",["431","432"],"import { Point } from '../../types';\nimport { useEffect } from 'react';\nimport { useOvermind } from '../../overmind';\nimport { undoBuffer } from '../../overmind/undo/UndoBuffer';\nimport { blobToCanvas } from './util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\n//import { renderToCanvasFrom } from '../../colorIndex/ColorIndexer';\n\nexport function useInitTool(\n  eventHandlerParams: EventHandlerParams,\n  eventHandlerParamsOverlay: EventHandlerParamsOverlay,\n  isZoomCanvas: boolean\n): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.previousTool?.onExit?.(eventHandlerParams);\n      state.toolbox.previousTool?.onExitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.previousTool]);\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.activeTool.onInit?.(eventHandlerParams);\n      state.toolbox.activeTool.onInitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.activeTool]);\n}\n\n// Update current fillStyle from state to canvas context when:\n// 1. fillStyle has been changed\n// 2. canvas resolution changes, as this also resets context\nexport function useFillStyle(ctx: CanvasRenderingContext2D | null): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (ctx) {\n      ctx.fillStyle = state.canvas.fillStyle;\n      ctx.strokeStyle = state.canvas.fillStyle;\n    }\n  }, [state.canvas.fillStyle, state.canvas.resolution]);\n}\n\nexport function useUndo(canvas: HTMLCanvasElement): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    //blobToCanvas(state.undo.currentBufferItem, canvas);\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (state.undo.currentIndex === null) {\n        return;\n      }\n      const colorIndex = undoBuffer.getItem(state.undo.currentIndex);\n      //renderToCanvasFrom(ctx, colorIndex);\n    }\n    console.log('undo hook end');\n  }, [state.undo.lastUndoRedoTime]);\n}\n\n// Load image to canvas when loadedImageURL changes\n// Changes canvas height and width to match image\nexport function useLoadedImage(canvas: HTMLCanvasElement): void {\n  const { state, actions } = useOvermind();\n  useEffect((): void => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n    const image = new Image();\n    image.onload = function (): void {\n      // No need to clear canvas, as changing dimensions clears it anyway.\n      // Note that context is also reset\n      actions.canvas.setResolution({ width: image.width, height: image.height });\n      ctx.drawImage(image, 0, 0);\n      actions.undo.setUndoPoint(canvas);\n      actions.canvas.setCanvasModified(false);\n    };\n    image.src = state.canvas.loadedImageURL;\n  }, [state.canvas.loadedImageURL]);\n}\n\nexport function useScrollToFocusPoint(\n  canvasDiv: HTMLDivElement,\n  focusPoint: Point | null,\n  zoomFactor = 1\n): void {\n  useEffect((): void => {\n    if (focusPoint === null) {\n      return;\n    }\n    const scrollOptions = {\n      left: focusPoint.x * zoomFactor - canvasDiv.clientWidth / 2,\n      top: focusPoint.y * zoomFactor - canvasDiv.clientHeight / 2,\n    };\n    canvasDiv.scrollTo(scrollOptions);\n  }, [focusPoint]);\n}\n","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts",["433","434"],"import { Action } from 'overmind';\nimport { BrushInterface } from '../../brush/Brush';\nimport { Mode, BuiltInBrushId, builtInBrushes } from './state';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { brushHistory } from '../../brush/BrushHistory';\n\nexport const setBrush: Action<BrushInterface> = ({ state }, brush): void => {\n  brushHistory.set(brush);\n};\n\nexport const selectBuiltInBrush: Action<BuiltInBrushId> = (\n  { state, actions },\n  brushNumber\n): void => {\n  state.brush.selectedBuiltInBrushId = brushNumber;\n  actions.brush.setBrush(builtInBrushes[brushNumber]);\n  actions.brush.setMode('Color');\n};\n\nexport const setMode: Action<Mode> = ({ state }, mode): void => {\n  state.brush.mode = mode;\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    if (mode === 'Color') {\n      brush.setFGColor(state.palette.foregroundColor);\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toFGColor();\n    } else if (mode === 'Matte') {\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toMatte();\n    }\n  }\n};\n\nexport const toFGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (state.brush.mode === 'Color' && brush instanceof CustomBrush) {\n    brush.toFGColor();\n  }\n  if (state.brush.mode === 'Matte' && brush instanceof CustomBrush) {\n    brush.toMatte();\n  }\n};\n\nexport const toBGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    brush.toBGColor();\n  }\n};\n","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx",["435"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport { getMousePos, clearOverlayCanvas, extractBrush } from './util/util';\nimport { overmind } from '../index';\nimport { selection } from './util/SelectionIndicator';\n\nexport class BrushSelector implements Tool {\n  public onInit(params: EventHandlerParams): void {\n    const {\n      ctx: { canvas },\n    } = params;\n    overmind.actions.tool.brushSelectionStart(null);\n    selection.prepare(canvas);\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const width = mousePos.x - start.x;\n    const height = mousePos.y - start.y;\n\n    const brush = extractBrush(canvas, start, width, height);\n    overmind.actions.brush.setBrush(brush);\n    overmind.actions.brush.setMode('Matte');\n\n    // exit brush selection tool\n    overmind.actions.toolbox.toggleBrushSelectionMode();\n    // switch to Dotted Freehand tool after selection\n    overmind.actions.toolbox.setSelectedDrawingTool('dottedFreehand');\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx } = params;\n    const mousePos = getMousePos(ctx.canvas, event);\n    overmind.actions.tool.brushSelectionStart(mousePos);\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    overmind.actions.tool.brushSelectionStart(null);\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      selection.edgeToEdgeCrosshair(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    selection.box(ctx, start, mousePos);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseUpOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx",["436","437"],"/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx",["438"],"/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx",["439"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  omit,\n  isLeftOrRightMouseButton,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class DottedFreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons) {\n      const mousePos = getMousePos(canvas, event);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts",["440"],"/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx",["441","442","443"],"/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts",["444","445"],"// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts",["446"],"import { GeometricIndexer } from './indexers/GeometricIndexer';\nimport { DrawImageIndexer } from './indexers/DrawImageIndexer';\nimport { CustomBrush } from '../brush/CustomBrush';\nimport { overmind } from '../index';\nimport { Line, Point } from '../types';\nimport { visualiseTexture } from './util';\n\nexport class ColorIndexer {\n  private gl: WebGLRenderingContext;\n  private fb: WebGLFramebuffer | null = null;\n  private geometricIndexer: GeometricIndexer;\n  private drawImageIndexer: DrawImageIndexer;\n\n  constructor(gl: WebGLRenderingContext) {\n    //this.gl = this.createIndexerGLContext(0, 0, 0);\n    this.gl = gl;\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n    this.resetIndex();\n  }\n\n  /*   private createIndexerGLContext(\n    width: number,\n    height: number,\n    backgroundColorId: number\n  ): WebGLRenderingContext {\n    // init a webgl context for a canvas element outside the DOM\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const gl = canvas.getContext('webgl', {\n      preserveDrawingBuffer: true,\n      antialias: false,\n    });\n\n    if (!gl) {\n      alert('Sorry, ReDPaint requires WebGL support:(');\n      throw 'Sorry, ReDPaint requires WebGL support';\n    }\n    return gl;\n  } */\n\n  /*   init(): void {\n    const width = overmind.state.canvas.resolution.width;\n    const height = overmind.state.canvas.resolution.height;\n    const backgroundColorId = Number(overmind.state.palette.backgroundColorId);\n    console.log(`ColorIndexer init, width=${width}, heigth=${height}`);\n    this.gl = this.createIndexerGLContext(width, height, backgroundColorId);\n\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n  } */\n\n  fillRect(start: Point, end: Point, colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexFillRect(start, end, colorIndex);\n  }\n\n  points(points: Point[], colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexPoints(points, colorIndex);\n  }\n\n  lines(lines: Line[], colorIndex: number): void {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fb);\n    this.geometricIndexer.indexLines(lines, colorIndex);\n  }\n\n  drawImage(x: number, y: number, brush: CustomBrush): void {\n    this.drawImageIndexer.indexDrawImage(x, y, brush);\n  }\n\n  getIndexAsCanvas(): HTMLCanvasElement | OffscreenCanvas {\n    return this.gl.canvas;\n  }\n\n  getIndex(): Uint8Array {\n    const pixels = new Uint8Array(this.gl.drawingBufferHeight * this.gl.drawingBufferWidth * 4);\n    this.gl.readPixels(\n      0,\n      0,\n      this.gl.drawingBufferWidth,\n      this.gl.drawingBufferHeight,\n      this.gl.RGBA,\n      this.gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  resetIndex(): void {\n    const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    // initialize the color index matrix with the background color\n    const backgroundColor = Number(overmind.state.palette.backgroundColorId);\n    const data = new Uint8Array(gl.drawingBufferHeight * gl.drawingBufferWidth * 4).fill(\n      backgroundColor\n    );\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      data\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    this.fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n  }\n\n  setIndex(index: Uint8Array | null): void {\n    /* if (!index) {\n      return;\n    }\n\n    const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      index\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n    */\n  }\n\n  getAreaFromIndex(\n    x: number, // canvas coord (origin upper left corner)\n    y: number, // canvas coord (origin upper left corner)\n    width: number, // canvas coord, can be negative\n    height: number // canvas coord, can be negative\n  ): Uint8Array | undefined {\n    const gl = this.gl;\n\n    // for readPixels we need to define the area with:\n    // - lower left corner of the area and\n    // - width and height as positive integers\n    // Texture coordinates\n\n    let rectLowerLeftX: number;\n    let rectLowerLeftY: number;\n\n    if (width < 0) {\n      rectLowerLeftX = x - Math.abs(width);\n    } else {\n      rectLowerLeftX = x;\n    }\n\n    if (height < 0) {\n      rectLowerLeftY = gl.drawingBufferHeight - y;\n    } else {\n      rectLowerLeftY = gl.drawingBufferHeight - y - Math.abs(height);\n    }\n\n    const pixels = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n    console.log('canvas: x:' + x + ' y: ' + y + ' w: ' + width + ' h: ' + height);\n    console.log(\n      'texture: x:' +\n        rectLowerLeftX +\n        ' y: ' +\n        rectLowerLeftY +\n        ' w: ' +\n        Math.abs(width) +\n        ' h: ' +\n        Math.abs(height)\n    );\n    console.log('gl.drawingBufferHeight: ' + gl.drawingBufferHeight);\n    gl.readPixels(\n      rectLowerLeftX,\n      rectLowerLeftY,\n      Math.abs(width),\n      Math.abs(height),\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  getColorIndexForPixel(point: Point): number | undefined {\n    const colorIndex = this.getAreaFromIndex(point.x, point.y, 1, 1);\n    return colorIndex?.[0];\n  }\n\n  // testing, debugging purposes only\n  visualiseIndex(): void {\n    const index = this.getIndex();\n    const width = this.gl.drawingBufferWidth;\n    visualiseTexture(index, width);\n  }\n}\n\n//export const colorIndexer = new ColorIndexer();\n","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts",["447"],"import { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../util';\n\nexport class GeometricIndexer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private currentColorIndex = 0;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public indexPoints(points: Point[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public indexLines(lines: Line[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  public indexFillRect(start: Point, end: Point, colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricIndexer');\n      gl.useProgram(this.program);\n    }\n\n    if (colorIndex !== this.currentColorIndex) {\n      console.log('updating color index uniform');\n      this.currentColorIndex = colorIndex;\n      const u_colorIndex = gl.getUniformLocation(this.program, 'u_colorIndex');\n      gl.uniform1f(u_colorIndex, colorIndex);\n    }\n\n    const width = end.x - start.x;\n    const height = end.y - start.y;\n\n    if (width === 1 && height === 1) {\n      this.fillRectPoint(start);\n    } else {\n      this.fillRectQuad(start, end);\n    }\n  }\n\n  private fillRectPoint(point: Point): void {\n    const gl = this.gl;\n\n    const shiftedPoint = shiftPoint(point);\n\n    const vertices = new Float32Array(2);\n    vertices[0] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n    vertices[1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, 1);\n  }\n\n  private fillRectQuad(start: Point, end: Point): void {\n    const gl = this.gl;\n\n    const shiftedStart = shiftPoint(start);\n    const shiftedEnd = shiftPoint(end);\n    const xLeft = canvasToWebGLCoordX(gl, shiftedStart.x);\n    const xRight = canvasToWebGLCoordX(gl, shiftedEnd.x);\n    const yTop = canvasToWebGLCoordInvert(gl, shiftedStart.y);\n    const yBottom = canvasToWebGLCoordInvert(gl, shiftedEnd.y);\n\n    const vertices = new Float32Array(8);\n    vertices[0] = xLeft;\n    vertices[1] = yTop;\n\n    vertices[2] = xLeft;\n    vertices[3] = yBottom;\n\n    vertices[4] = xRight;\n    vertices[5] = yTop;\n\n    vertices[6] = xRight;\n    vertices[7] = yBottom;\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform float u_colorIndex;\n\n    void main () {\n      gl_FragColor = vec4(u_colorIndex/255.0, 0.0, 0.0, 1.0);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile to program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n    console.log('Program ready (GeometricIndexer)');\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts",["448","449"],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts",["450"],"/* eslint-disable max-len */\nimport { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../../colorIndex/util';\nimport { overmind } from '../..';\n\nexport class OverlayGeometricRenderer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private currentColorIndex = 0;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public renderPoints(points: Point[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public renderLines(lines: Line[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  private updateColor(colorIndex: number) {\n    if (colorIndex == this.currentColorIndex) {\n      return;\n    }\n\n    if (!this.program) {\n      return;\n    }\n    const gl = this.gl;\n\n    console.log('updating color uniform');\n    this.currentColorIndex = colorIndex;\n    const color = overmind.state.palette.paletteArray[colorIndex - 1];\n    const u_color = gl.getUniformLocation(this.program, 'u_color');\n    gl.uniform3f(u_color, color.r, color.g, color.b);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform vec3 u_color;\n\n    void main () {\n      gl_FragColor = vec4(u_color.x/255.0, u_color.y/255.0, u_color.z/255.0, 1.0);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile to program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n    console.log('Program ready (FillRectIndexer)');\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricIndexer.ts",["451"],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/GeometricRenderer.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/PaintingCanvasController.ts",["452","453"],"/* eslint-disable max-len */\nimport { overmind } from '../..';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { visualiseTexture } from '../../colorIndex/util';\nimport { Throttle } from '../../tools/util/Throttle';\nimport { Line, Point } from '../../types';\nimport { CanvasController } from '../CanvasController';\nimport { DrawImageIndexer } from './program/DrawImageIndexer';\nimport { DrawImageRenderer } from './program/DrawImageRenderer';\nimport { GeometricIndexer } from './program/GeometricIndexer';\nimport { GeometricRenderer } from './program/GeometricRenderer';\n\n// PaintingCanvasController is a singleton responsible for controlling\n// the two painting canvases in the app: MainCanvas and ZoomCanvas.\n// Note that overlay canvases are controllod separately by OverlayCanvasController.\nexport class PaintingCanvasController implements CanvasController {\n  private mainCanvas: HTMLCanvasElement;\n  private gl: WebGLRenderingContext | null = null;\n\n  private zoomCanvas: HTMLCanvasElement;\n  private zoomCanvasCtx: CanvasRenderingContext2D | null = null;\n\n  private geometricIndexer: GeometricIndexer | null = null;\n  private drawImageIndexer: DrawImageIndexer | null = null;\n  private geometricRenderer: GeometricRenderer | null = null;\n  private drawImageRenderer: DrawImageRenderer | null = null;\n\n  private throttle = new Throttle(1000 / 60);\n  private colorIndexFrameBuffer: WebGLFramebuffer | null = null;\n\n  public buffers: { vertexBuffer: WebGLBuffer | null; textureCoordBuffer: WebGLBuffer | null } = {\n    vertexBuffer: null,\n    textureCoordBuffer: null,\n  };\n\n  constructor() {\n    this.mainCanvas = document.createElement('canvas');\n    this.zoomCanvas = document.createElement('canvas');\n  }\n\n  attachMainCanvas(mainCanvas: HTMLCanvasElement): void {\n    this.mainCanvas = mainCanvas;\n\n    const gl = mainCanvas.getContext('webgl', {\n      preserveDrawingBuffer: true,\n      antialias: false,\n    });\n    if (!gl) {\n      throw 'No webgl';\n    }\n    this.gl = gl;\n    this.init();\n  }\n\n  attachZoomCanvas(zoomCanvas: HTMLCanvasElement): void {\n    this.zoomCanvas = zoomCanvas;\n    this.zoomCanvasCtx = zoomCanvas.getContext('2d', {\n      alpha: true,\n      // desynchronized caused various problems with Windows version of Chrome\n      // TODO: test again with the new version\n      desynchronized: false,\n    });\n  }\n\n  points(points: Point[], colorIndex: number): void {\n    this.geometricIndexer?.indexPoints(points, colorIndex);\n    this.geometricRenderer?.renderPoints(points);\n    this.renderZoomCanvas();\n  }\n\n  lines(lines: Line[], colorIndex: number): void {\n    //TODO\n  }\n\n  drawImage(points: Point[], brush: CustomBrush): void {\n    this.drawImageIndexer?.indexDrawImage(points, brush);\n    this.drawImageRenderer?.renderCanvas();\n    this.renderZoomCanvas();\n  }\n\n  renderZoomCanvas(): void {\n    if (!overmind.state.toolbox.zoomModeOn) {\n      return;\n    }\n    // maybe not necessary to clear canvas?\n    //this.zoomCanvasCtx?.clearRect(0, 0, this.zoomCanvas.width, this.zoomCanvas.height);\n    this.zoomCanvasCtx?.drawImage(this.mainCanvas, 0, 0);\n    /*\n    // throttle copying to zoomCanvas when drawing on mainCanvas\n    // This an optimization for Firefox where copying from gl canvas to 2d canvas is slow\n    this.throttle.call((): void => {\n      this.zoomCanvasCtx?.drawImage(this.mainCanvas, 0, 0);\n    }); */\n  }\n\n  getIndex(): Uint8Array {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.colorIndexFrameBuffer);\n\n    const pixels = new Uint8Array(gl.drawingBufferHeight * gl.drawingBufferWidth * 4);\n    gl.readPixels(\n      0,\n      0,\n      gl.drawingBufferWidth,\n      gl.drawingBufferHeight,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return pixels;\n  }\n\n  // testing, debugging purposes only\n  visualiseIndex(): void {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    const index = this.getIndex();\n    const width = gl.drawingBufferWidth;\n    visualiseTexture(index, width);\n  }\n\n  getAreaFromIndex(\n    x: number, // canvas coord (origin upper left corner)\n    y: number, // canvas coord (origin upper left corner)\n    width: number, // canvas coord, can be negative\n    height: number // canvas coord, can be negative\n  ): Uint8Array | undefined {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    // for readPixels we need to define the area with:\n    // - lower left corner of the area and\n    // - width and height as positive integers\n    // Texture coordinates\n\n    let rectLowerLeftX: number;\n    let rectLowerLeftY: number;\n\n    if (width < 0) {\n      rectLowerLeftX = x - Math.abs(width);\n    } else {\n      rectLowerLeftX = x;\n    }\n\n    if (height < 0) {\n      rectLowerLeftY = gl.drawingBufferHeight - y;\n    } else {\n      rectLowerLeftY = gl.drawingBufferHeight - y - Math.abs(height);\n    }\n\n    const pixels = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n    console.log('canvas: x:' + x + ' y: ' + y + ' w: ' + width + ' h: ' + height);\n    console.log(\n      'texture: x:' +\n        rectLowerLeftX +\n        ' y: ' +\n        rectLowerLeftY +\n        ' w: ' +\n        Math.abs(width) +\n        ' h: ' +\n        Math.abs(height)\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.colorIndexFrameBuffer);\n    gl.readPixels(\n      rectLowerLeftX,\n      y,\n      Math.abs(width),\n      Math.abs(height),\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return pixels;\n  }\n\n  init(): void {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    // color index texture always in texture unit 0\n    // palette texture always in texture unit 1\n    // brush texture always in texture unit 2\n\n    const colorIndexFramebuffer = this.initColorIndexTexture();\n    this.colorIndexFrameBuffer = colorIndexFramebuffer;\n    this.initPaletteTexture();\n    this.initVertexBuffer();\n    this.initTextureCoordBuffer();\n\n    this.geometricIndexer = new GeometricIndexer(gl, colorIndexFramebuffer);\n    this.drawImageIndexer = new DrawImageIndexer(gl, colorIndexFramebuffer, this);\n\n    this.geometricRenderer = new GeometricRenderer(gl);\n    this.drawImageRenderer = new DrawImageRenderer(gl);\n  }\n\n  private initColorIndexTexture(): WebGLFramebuffer {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    // Initialize the color index texture.\n    // This texture is used both as a render target (when indexing)\n    // and as source texture (when rendering).\n\n    // As a source texture we store the color index in texture unit 0 so we\n    // call gl.activeTexture before gl.bindTexture\n\n    gl.activeTexture(gl.TEXTURE0);\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = overmind.state.canvas.resolution.width;\n    const targetTextureHeight = overmind.state.canvas.resolution.height;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    // initialize the color index matrix with the background color\n    const backgroundColor = Number(overmind.state.palette.backgroundColorId);\n    const data = new Uint8Array(targetTextureHeight * targetTextureWidth * 4).fill(backgroundColor);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      data\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    gl.viewport(0, 0, targetTextureWidth, targetTextureHeight);\n\n    // Create a framebuffer for rendering to this texture and store the reference.\n\n    const colorIndexFramebuffer = gl.createFramebuffer();\n    if (!colorIndexFramebuffer) {\n      throw 'Failed to create framebuffer for color index';\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, colorIndexFramebuffer);\n\n    // attach the texture as the first color attachment of the framebuffer\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n\n    return colorIndexFramebuffer;\n  }\n\n  private initPaletteTexture(): void {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    const paletteTexture = new Uint8Array(256 * 4);\n    const palette = overmind.state.palette.paletteArray;\n    for (let i = 0; i < palette.length; i++) {\n      paletteTexture[i * 4 + 0] = palette[i].r;\n      paletteTexture[i * 4 + 1] = palette[i].g;\n      paletteTexture[i * 4 + 2] = palette[i].b;\n      paletteTexture[i * 4 + 3] = 255;\n    }\n\n    // We store the palette as a source texture in texture unit 1 so we\n    // call gl.activeTexture before gl.bindTexture\n\n    gl.activeTexture(gl.TEXTURE1);\n\n    const paletteTex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, paletteTex);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, paletteTexture);\n  }\n\n  private initVertexBuffer(): void {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    // Create a common buffer object for vertex coordinates.\n    // This will be used by all shaders.\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      throw 'Failed to create a buffer object for vertex coordinates';\n    }\n\n    // Bind the buffer object to target (this is the default)\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    this.buffers.vertexBuffer = vertexBuffer;\n  }\n\n  private initTextureCoordBuffer(): void {\n    const gl = this.gl;\n    if (!gl) {\n      throw 'No webgl';\n    }\n\n    // Create a buffer object for texture coordinates\n    const textureCoordBuffer = gl.createBuffer();\n    if (!textureCoordBuffer) {\n      throw 'Failed to create the buffer object (textureCoordBuffer)';\n    }\n\n    this.buffers.textureCoordBuffer = textureCoordBuffer;\n  }\n}\n\nexport const paintingCanvasController = new PaintingCanvasController();\n","/Users/jani/Code/Web/dxpaint/src/canvas/util.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/webglUtil.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/paintingCanvas/program/DrawImageIndexer.ts",[],"/Users/jani/Code/Web/dxpaint/src/canvas/overlayCanvas/OverlayCanvasController.ts",["454"],{"ruleId":"455","severity":1,"message":"456","line":55,"column":10,"nodeType":"457","messageId":"458","endLine":55,"endColumn":20},{"ruleId":"455","severity":1,"message":"456","line":64,"column":10,"nodeType":"457","messageId":"458","endLine":64,"endColumn":27},{"ruleId":"459","severity":1,"message":"460","line":3,"column":10,"nodeType":"461","messageId":"462","endLine":3,"endColumn":19},{"ruleId":"459","severity":1,"message":"463","line":5,"column":3,"nodeType":"461","messageId":"462","endLine":5,"endColumn":7},{"ruleId":"459","severity":1,"message":"464","line":29,"column":17,"nodeType":"461","messageId":"462","endLine":29,"endColumn":43},{"ruleId":"459","severity":1,"message":"464","line":27,"column":17,"nodeType":"461","messageId":"462","endLine":27,"endColumn":43},{"ruleId":"455","severity":1,"message":"456","line":22,"column":26,"nodeType":"457","messageId":"458","endLine":22,"endColumn":39},{"ruleId":"459","severity":1,"message":"463","line":4,"column":3,"nodeType":"461","messageId":"462","endLine":4,"endColumn":7},{"ruleId":"459","severity":1,"message":"465","line":6,"column":3,"nodeType":"461","messageId":"462","endLine":6,"endColumn":17},{"ruleId":"459","severity":1,"message":"466","line":7,"column":3,"nodeType":"461","messageId":"462","endLine":7,"endColumn":15},{"ruleId":"459","severity":1,"message":"467","line":8,"column":3,"nodeType":"461","messageId":"462","endLine":8,"endColumn":13},{"ruleId":"459","severity":1,"message":"468","line":20,"column":10,"nodeType":"461","messageId":"462","endLine":20,"endColumn":21},{"ruleId":"459","severity":1,"message":"464","line":31,"column":17,"nodeType":"461","messageId":"462","endLine":31,"endColumn":43},{"ruleId":"459","severity":1,"message":"464","line":28,"column":17,"nodeType":"461","messageId":"462","endLine":28,"endColumn":43},{"ruleId":"459","severity":1,"message":"464","line":34,"column":17,"nodeType":"461","messageId":"462","endLine":34,"endColumn":43},{"ruleId":"459","severity":1,"message":"469","line":5,"column":10,"nodeType":"461","messageId":"462","endLine":5,"endColumn":22},{"ruleId":"459","severity":1,"message":"470","line":51,"column":13,"nodeType":"461","messageId":"462","endLine":51,"endColumn":23},{"ruleId":"459","severity":1,"message":"471","line":7,"column":52,"nodeType":"461","messageId":"462","endLine":7,"endColumn":57},{"ruleId":"459","severity":1,"message":"471","line":45,"column":37,"nodeType":"461","messageId":"462","endLine":45,"endColumn":42},{"ruleId":"459","severity":1,"message":"464","line":56,"column":23,"nodeType":"461","messageId":"462","endLine":56,"endColumn":58},{"ruleId":"459","severity":1,"message":"472","line":4,"column":10,"nodeType":"461","messageId":"462","endLine":4,"endColumn":34},{"ruleId":"459","severity":1,"message":"473","line":17,"column":11,"nodeType":"461","messageId":"462","endLine":17,"endColumn":19},{"ruleId":"459","severity":1,"message":"474","line":13,"column":10,"nodeType":"461","messageId":"462","endLine":13,"endColumn":33},{"ruleId":"459","severity":1,"message":"464","line":25,"column":17,"nodeType":"461","messageId":"462","endLine":25,"endColumn":43},{"ruleId":"459","severity":1,"message":"472","line":2,"column":10,"nodeType":"461","messageId":"462","endLine":2,"endColumn":34},{"ruleId":"455","severity":1,"message":"456","line":67,"column":7,"nodeType":"457","messageId":"458","endLine":67,"endColumn":30,"suggestions":"475"},{"ruleId":"455","severity":1,"message":"456","line":86,"column":7,"nodeType":"457","messageId":"458","endLine":86,"endColumn":30,"suggestions":"476"},{"ruleId":"477","severity":1,"message":"478","line":92,"column":39,"nodeType":"479","messageId":"480","endLine":92,"endColumn":42,"suggestions":"481"},{"ruleId":"482","severity":1,"message":"483","line":26,"column":8,"nodeType":"484","messageId":"485","endLine":26,"endColumn":42},{"ruleId":"482","severity":1,"message":"483","line":133,"column":8,"nodeType":"484","messageId":"485","endLine":133,"endColumn":29},{"ruleId":"459","severity":1,"message":"486","line":144,"column":12,"nodeType":"461","messageId":"462","endLine":144,"endColumn":36},{"ruleId":"459","severity":1,"message":"487","line":5,"column":3,"nodeType":"461","messageId":"462","endLine":5,"endColumn":22},{"ruleId":"459","severity":1,"message":"487","line":6,"column":3,"nodeType":"461","messageId":"462","endLine":6,"endColumn":22},{"ruleId":"459","severity":1,"message":"472","line":10,"column":10,"nodeType":"461","messageId":"462","endLine":10,"endColumn":34},{"ruleId":"459","severity":1,"message":"487","line":6,"column":3,"nodeType":"461","messageId":"462","endLine":6,"endColumn":22},{"ruleId":"459","severity":1,"message":"488","line":1,"column":10,"nodeType":"461","messageId":"462","endLine":1,"endColumn":14},{"ruleId":"459","severity":1,"message":"489","line":71,"column":9,"nodeType":"461","messageId":"462","endLine":71,"endColumn":22},{"ruleId":"459","severity":1,"message":"490","line":71,"column":24,"nodeType":"461","messageId":"462","endLine":71,"endColumn":42},{"ruleId":"459","severity":1,"message":"491","line":1,"column":10,"nodeType":"461","messageId":"462","endLine":1,"endColumn":21},"@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","@typescript-eslint/no-unused-vars","'drawImage' is defined but never used.","Identifier","unusedVar","'line' is defined but never used.","'params' is defined but never used.","'unfilledCircle' is defined but never used.","'filledCircle' is defined but never used.","'filledRect' is defined but never used.","'pointEquals' is defined but never used.","'blobToCanvas' is defined but never used.","'colorIndex' is assigned a value but never used.","'state' is defined but never used.","'paintingCanvasController' is defined but never used.","'mousePos' is assigned a value but never used.","'overlayCanvasController' is defined but never used.",["492"],["493"],"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["494","495"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","'index' is defined but never used.","'canvasToWebGLCoordY' is defined but never used.","'Line' is defined but never used.","'lines' is defined but never used.","'colorIndex' is defined but never used.","'CustomBrush' is defined but never used.",{"messageId":"496","fix":"497","desc":"498"},{"messageId":"496","fix":"499","desc":"498"},{"messageId":"500","fix":"501","desc":"502"},{"messageId":"503","fix":"504","desc":"505"},"suggestOptionalChain",{"range":"506","text":"507"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"508","text":"507"},"suggestUnknown",{"range":"509","text":"510"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"509","text":"511"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",[2289,2290],"?.",[2928,2929],[3109,3112],"unknown","never"]