[{"/Users/jani/Code/Web/dxpaint/src/index.tsx":"1","/Users/jani/Code/Web/dxpaint/src/components/App.tsx":"2","/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx":"3","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx":"4","/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx":"5","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx":"6","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts":"7","/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts":"8","/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts":"9","/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts":"10","/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx":"11","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx":"12","/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx":"13","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts":"14","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts":"15","/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts":"16","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts":"17","/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts":"18","/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts":"19","/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts":"20","/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx":"21","/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx":"22","/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx":"23","/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx":"24","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx":"25","/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx":"26","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts":"27","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx":"28","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx":"29","/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx":"30","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts":"31","/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts":"32","/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts":"33","/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts":"34","/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx":"35","/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx":"36","/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx":"37","/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx":"38","/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx":"39","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx":"40","/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx":"41","/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx":"42","/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx":"43","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx":"44","/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx":"45","/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx":"46","/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx":"47","/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx":"48","/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts":"49","/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts":"50","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts":"51","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx":"52","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx":"53","/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts":"54","/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts":"55","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx":"56","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx":"57","/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx":"58","/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx":"59","/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts":"60","/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts":"61","/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx":"62","/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx":"63","/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts":"64","/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts":"65","/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx":"66","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts":"67","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts":"68","/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx":"69","/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx":"70","/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts":"71","/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts":"72","/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts":"73","/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx":"74","/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx":"75","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts":"76","/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts":"77","/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts":"78","/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx":"79","/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts":"80","/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx":"81","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts":"82","/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts":"83","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts":"84","/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts":"85","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts":"86","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts":"87","/Users/jani/Code/Web/dxpaint/src/core/OverlayCanvasController.ts":"88","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts":"89","/Users/jani/Code/Web/dxpaint/src/core/PaintingCanvasController.ts":"90","/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts":"91"},{"size":758,"mtime":1581006660054,"results":"92","hashOfConfig":"93"},{"size":1647,"mtime":1610123744119,"results":"94","hashOfConfig":"93"},{"size":2303,"mtime":1587397395180,"results":"95","hashOfConfig":"93"},{"size":1650,"mtime":1587397383935,"results":"96","hashOfConfig":"93"},{"size":4292,"mtime":1588883165180,"results":"97","hashOfConfig":"93"},{"size":1341,"mtime":1609964713351,"results":"98","hashOfConfig":"93"},{"size":99,"mtime":1570358386366,"results":"99","hashOfConfig":"93"},{"size":99,"mtime":1589653071467,"results":"100","hashOfConfig":"93"},{"size":99,"mtime":1581162181250,"results":"101","hashOfConfig":"93"},{"size":371,"mtime":1598417463850,"results":"102","hashOfConfig":"93"},{"size":5404,"mtime":1615708990658,"results":"103","hashOfConfig":"93"},{"size":712,"mtime":1586637521430,"results":"104","hashOfConfig":"93"},{"size":6667,"mtime":1613232457299,"results":"105","hashOfConfig":"93"},{"size":103,"mtime":1589645340777,"results":"106","hashOfConfig":"93"},{"size":238,"mtime":1589698799652,"results":"107","hashOfConfig":"93"},{"size":994,"mtime":1610288900130,"results":"108","hashOfConfig":"93"},{"size":2307,"mtime":1587665133808,"results":"109","hashOfConfig":"93"},{"size":3939,"mtime":1606591580738,"results":"110","hashOfConfig":"93"},{"size":775,"mtime":1598628605933,"results":"111","hashOfConfig":"93"},{"size":16100,"mtime":1616243079098,"results":"112","hashOfConfig":"93"},{"size":3763,"mtime":1616095559822,"results":"113","hashOfConfig":"93"},{"size":2427,"mtime":1598195635333,"results":"114","hashOfConfig":"93"},{"size":5449,"mtime":1598418063310,"results":"115","hashOfConfig":"93"},{"size":3269,"mtime":1598417920855,"results":"116","hashOfConfig":"93"},{"size":3137,"mtime":1614154844644,"results":"117","hashOfConfig":"93"},{"size":749,"mtime":1606592951751,"results":"118","hashOfConfig":"93"},{"size":1069,"mtime":1609948473281,"results":"119","hashOfConfig":"93"},{"size":419,"mtime":1586636737515,"results":"120","hashOfConfig":"93"},{"size":1292,"mtime":1615622215367,"results":"121","hashOfConfig":"93"},{"size":448,"mtime":1606592971846,"results":"122","hashOfConfig":"93"},{"size":990,"mtime":1606591610390,"results":"123","hashOfConfig":"93"},{"size":163,"mtime":1616686264476,"results":"124","hashOfConfig":"93"},{"size":787,"mtime":1610395467992,"results":"125","hashOfConfig":"93"},{"size":3492,"mtime":1598088214899,"results":"126","hashOfConfig":"93"},{"size":3447,"mtime":1616243072391,"results":"127","hashOfConfig":"93"},{"size":2981,"mtime":1615722971654,"results":"128","hashOfConfig":"93"},{"size":1686,"mtime":1596966551515,"results":"129","hashOfConfig":"93"},{"size":3062,"mtime":1598418004456,"results":"130","hashOfConfig":"93"},{"size":4424,"mtime":1598418176200,"results":"131","hashOfConfig":"93"},{"size":620,"mtime":1609948514564,"results":"132","hashOfConfig":"93"},{"size":1542,"mtime":1610828201690,"results":"133","hashOfConfig":"93"},{"size":1328,"mtime":1576359001814,"results":"134","hashOfConfig":"93"},{"size":3226,"mtime":1613738313456,"results":"135","hashOfConfig":"93"},{"size":849,"mtime":1582737330219,"results":"136","hashOfConfig":"93"},{"size":1947,"mtime":1613737455235,"results":"137","hashOfConfig":"93"},{"size":794,"mtime":1589698776952,"results":"138","hashOfConfig":"93"},{"size":5255,"mtime":1613737486628,"results":"139","hashOfConfig":"93"},{"size":1298,"mtime":1589699509988,"results":"140","hashOfConfig":"93"},{"size":99,"mtime":1570358390587,"results":"141","hashOfConfig":"93"},{"size":99,"mtime":1570358382606,"results":"142","hashOfConfig":"93"},{"size":99,"mtime":1570358454848,"results":"143","hashOfConfig":"93"},{"size":479,"mtime":1586285629987,"results":"144","hashOfConfig":"93"},{"size":691,"mtime":1582737314794,"results":"145","hashOfConfig":"93"},{"size":197,"mtime":1589653419630,"results":"146","hashOfConfig":"93"},{"size":1538,"mtime":1613232457299,"results":"147","hashOfConfig":"93"},{"size":2633,"mtime":1596966551507,"results":"148","hashOfConfig":"93"},{"size":4663,"mtime":1615896850513,"results":"149","hashOfConfig":"93"},{"size":1205,"mtime":1616243362895,"results":"150","hashOfConfig":"93"},{"size":2017,"mtime":1597691407920,"results":"151","hashOfConfig":"93"},{"size":99,"mtime":1589645298846,"results":"152","hashOfConfig":"93"},{"size":1538,"mtime":1616244139282,"results":"153","hashOfConfig":"93"},{"size":3801,"mtime":1615966689781,"results":"154","hashOfConfig":"93"},{"size":3797,"mtime":1596966551513,"results":"155","hashOfConfig":"93"},{"size":99,"mtime":1570358463891,"results":"156","hashOfConfig":"93"},{"size":3476,"mtime":1606591793814,"results":"157","hashOfConfig":"93"},{"size":2892,"mtime":1598418027518,"results":"158","hashOfConfig":"93"},{"size":221,"mtime":1609964687396,"results":"159","hashOfConfig":"93"},{"size":94,"mtime":1609948309696,"results":"160","hashOfConfig":"93"},{"size":1140,"mtime":1610122119190,"results":"161","hashOfConfig":"93"},{"size":2782,"mtime":1610122387748,"results":"162","hashOfConfig":"93"},{"size":3111,"mtime":1613738274657,"results":"163","hashOfConfig":"93"},{"size":1841,"mtime":1615576399763,"results":"164","hashOfConfig":"93"},{"size":1195,"mtime":1616243346341,"results":"165","hashOfConfig":"93"},{"size":3361,"mtime":1610827576318,"results":"166","hashOfConfig":"93"},{"size":6322,"mtime":1616243037717,"results":"167","hashOfConfig":"93"},{"size":99,"mtime":1609948228471,"results":"168","hashOfConfig":"93"},{"size":129,"mtime":1589653235884,"results":"169","hashOfConfig":"93"},{"size":424,"mtime":1611407191206,"results":"170","hashOfConfig":"93"},{"size":758,"mtime":1616082227415,"results":"171","hashOfConfig":"93"},{"size":5183,"mtime":1615012131754,"results":"172","hashOfConfig":"93"},{"size":4028,"mtime":1584903623805,"results":"173","hashOfConfig":"93"},{"size":6009,"mtime":1613307455776,"results":"174","hashOfConfig":"93"},{"size":7197,"mtime":1616241628772,"results":"175","hashOfConfig":"93"},{"size":6567,"mtime":1615967420911,"results":"176","hashOfConfig":"93"},{"size":3758,"mtime":1616243873408,"results":"177","hashOfConfig":"93"},{"size":3848,"mtime":1616242715675,"results":"178","hashOfConfig":"93"},{"size":6616,"mtime":1616243548217,"results":"179","hashOfConfig":"93"},{"size":2561,"mtime":1616242957893,"results":"180","hashOfConfig":"93"},{"size":4844,"mtime":1615909450457,"results":"181","hashOfConfig":"93"},{"size":3146,"mtime":1616244177789,"results":"182","hashOfConfig":"93"},{"size":1780,"mtime":1616095301317,"results":"183","hashOfConfig":"93"},{"filePath":"184","messages":"185","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},"1plr3f1",{"filePath":"187","messages":"188","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"189","messages":"190","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"192","messages":"193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"194"},{"filePath":"195","messages":"196","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"197","messages":"198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"203"},{"filePath":"204","messages":"205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"208"},{"filePath":"209","messages":"210","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211","usedDeprecatedRules":"186"},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"216","messages":"217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"218"},{"filePath":"219","messages":"220","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"221","messages":"222","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"223","messages":"224","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"225","messages":"226","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"228","messages":"229","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"232","messages":"233","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"234","usedDeprecatedRules":"186"},{"filePath":"235","messages":"236","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"237","messages":"238","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"239","messages":"240","errorCount":1,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"241","usedDeprecatedRules":"191"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"244","messages":"245","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"246","usedDeprecatedRules":"186"},{"filePath":"247","messages":"248","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"249","messages":"250","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"251","messages":"252","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"253","messages":"254","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"255","messages":"256","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"259","messages":"260","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"261","messages":"262","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"263","messages":"264","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"265","messages":"266","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"267","messages":"268","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"203"},{"filePath":"269","messages":"270","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"271","usedDeprecatedRules":"194"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"274","usedDeprecatedRules":"191"},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"283","usedDeprecatedRules":"203"},{"filePath":"284","messages":"285","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"286","messages":"287","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"288","messages":"289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"194"},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"292","messages":"293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"294","messages":"295","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"296","messages":"297","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"298"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"303","messages":"304","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"305","messages":"306","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"307","messages":"308","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"309","usedDeprecatedRules":"186"},{"filePath":"310","messages":"311","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"312","usedDeprecatedRules":"186"},{"filePath":"313","messages":"314","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"315","messages":"316","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"317","messages":"318","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"319","messages":"320","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"321","messages":"322","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"323","messages":"324","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"325","usedDeprecatedRules":"186"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"328","messages":"329","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"330","messages":"331","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"218"},{"filePath":"332","messages":"333","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"334","usedDeprecatedRules":"186"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"339","messages":"340","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"341","messages":"342","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"191"},{"filePath":"343","messages":"344","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"345","messages":"346","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"351","messages":"352","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"353","usedDeprecatedRules":"186"},{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"356"},{"filePath":"357","messages":"358","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"359","messages":"360","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"227"},{"filePath":"361","messages":"362","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"363","messages":"364","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"365","messages":"366","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"367","messages":"368","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"369","messages":"370","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"371","usedDeprecatedRules":"186"},{"filePath":"372","messages":"373","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"374","messages":"375","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"376","messages":"377","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"186"},{"filePath":"378","messages":"379","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"380"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"383","usedDeprecatedRules":"186"},{"filePath":"384","messages":"385","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"386"},{"filePath":"387","messages":"388","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"389","messages":"390","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/jani/Code/Web/dxpaint/src/index.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/App.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/ZoomCanvas.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasSyncHandler.tsx",[],[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/BuiltInBrushes.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorIndicator.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/brush/BrushHistory.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/Canvas.tsx",["391","392"],"import React, { useEffect, useRef } from 'react';\nimport { CanvasStateAction } from './CanvasState';\nimport { useInitTool, useUndo, useFillStyle } from './hooks';\nimport { useOvermind } from '../../overmind';\nimport { getEventHandler, getEventHandlerOverlay } from '../../tools/util/util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\nimport './Canvas.css';\nimport { paintingCanvasController } from '../../core/PaintingCanvasController';\nimport { overlayCanvasController } from '../../core/OverlayCanvasController';\n\ninterface Props {\n  canvasDispatch: React.Dispatch<CanvasStateAction>;\n  isZoomCanvas: boolean;\n  zoomFactor?: number;\n}\n\nexport function Canvas({\n  canvasDispatch,\n  isZoomCanvas,\n  zoomFactor = 1,\n}: Props): JSX.Element | null {\n  console.log('render ' + (isZoomCanvas ? 'ZoomCanvas' : 'MainCanvas'));\n  const canvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const paintingCanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n  const overlay2CanvasRef = useRef<HTMLCanvasElement>(document.createElement('canvas'));\n\n  useEffect((): void => {\n    canvasDispatch({\n      type: isZoomCanvas ? 'setZoomCanvas' : 'setMainCanvas',\n      elements: { canvas: canvasRef.current, overlay: overlayCanvasRef.current },\n    });\n    if (isZoomCanvas) {\n      paintingCanvasController.attachZoomCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachZoomCanvas(overlay2CanvasRef.current);\n    } else {\n      paintingCanvasController.attachMainCanvas(paintingCanvasRef.current);\n      overlayCanvasController.attachMainCanvas(overlay2CanvasRef.current);\n    }\n  }, []);\n\n  const canvasCtx = canvasRef.current.getContext('2d', {\n    alpha: false,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const overlayCanvasCtx = overlayCanvasRef.current.getContext('2d', {\n    alpha: true,\n    desynchronized: false, // desynchronized caused various problems with Windows version of Chrome\n  }) as CanvasRenderingContext2D | null;\n\n  const { state, actions } = useOvermind();\n\n  const eventHandlerParams: EventHandlerParams = {\n    ctx: canvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setCanvasModified(isZoomCanvas);\n    },\n    undoPoint: (): void => {\n      actions.undo.setUndoPoint(canvasRef.current);\n    },\n  };\n  const eventHandlerParamsOverlay: EventHandlerParamsOverlay = {\n    ctx: overlayCanvasCtx!,\n    onPaint: (): void => {\n      //actions.canvas.setOverlayCanvasModified(isZoomCanvas);\n    },\n  };\n\n  useUndo(canvasRef.current);\n  useInitTool(eventHandlerParams, eventHandlerParamsOverlay, isZoomCanvas);\n\n  useFillStyle(canvasCtx);\n  useFillStyle(overlayCanvasCtx);\n\n  if (!canvasCtx || !overlayCanvasCtx) {\n    return null; // no render\n  }\n\n  const tool = state.toolbox.activeTool;\n\n  const CSSZoom = {\n    width: state.canvas.resolution.width * zoomFactor,\n    height: state.canvas.resolution.height * zoomFactor,\n  };\n\n  return (\n    <>\n      <canvas\n        className=\"canvas\"\n        ref={canvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n        onClick={(event): void => {\n          getEventHandler(tool, 'onClick', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onClickOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseDown={(event): void => {\n          getEventHandler(tool, 'onMouseDown', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseDownOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseUp={(event): void => {\n          getEventHandler(tool, 'onMouseUp', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseUpOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseEnter={(event): void => {\n          getEventHandler(tool, 'onMouseEnter', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseEnterOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseLeave={(event): void => {\n          getEventHandler(tool, 'onMouseLeave', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseLeaveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onMouseMove={(event): void => {\n          getEventHandler(tool, 'onMouseMove', eventHandlerParams)(event);\n          getEventHandlerOverlay(tool, 'onMouseMoveOverlay', eventHandlerParamsOverlay)(event);\n        }}\n        onContextMenu={getEventHandler(tool, 'onContextMenu', eventHandlerParams)}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={paintingCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlay2CanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n      <canvas\n        className=\"canvas canvas--overlay\"\n        ref={overlayCanvasRef}\n        width={state.canvas.resolution.width}\n        height={state.canvas.resolution.height}\n        style={CSSZoom}\n      />\n    </>\n  );\n}\n","/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemOpen.tsx",[],"/Users/jani/Code/Web/dxpaint/src/brush/CustomBrush.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/state.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/state.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/shape.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/FreehandTool.tsx",["393"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n  pointEquals,\n  points8Connected,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\nimport { paintingCanvasController } from '../core/PaintingCanvasController';\nimport { overlayCanvasController } from '../core/OverlayCanvasController';\n\nexport class FreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.freeHandToolPrevious(null);\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons && overmind.state.tool.freehandTool.previous) {\n      const mousePos = getMousePos(canvas, event);\n      const start = overmind.state.tool.freehandTool.previous;\n      const end = mousePos;\n      if (pointEquals(start, end)) {\n        return; // this point has already been drawn to canvas\n      }\n      if (points8Connected(start, end)) {\n        brushHistory.current.drawDot(ctx, end, paintingCanvasController);\n      } else {\n        brushHistory.current.drawLine(ctx, start, end, paintingCanvasController);\n      }\n      overmind.actions.tool.freeHandToolPrevious(end);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos, paintingCanvasController);\n    overmind.actions.tool.freeHandToolPrevious(mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    //clearOverlayCanvas(canvas);\n    const mousePos = getMousePos(canvas, event);\n    //brushHistory.current.drawDot(ctx, mousePos);\n    brushHistory.current.drawDot(ctx, mousePos, overlayCanvasController);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/components/palette/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/EllipseTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/AirbrushTool.tsx",["394","395"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class AirbrushTool implements Tool {\n  private timeout = 0;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    overmind.actions.tool.airbrushToolPosition(mousePos);\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx, onPaint } = params;\n\n    const draw = (ctx: CanvasRenderingContext2D, onPaint: Function): void => {\n      for (let i = 50; i--; ) {\n        const angle = getRandomFloat(0, Math.PI * 2);\n        const radius = getRandomFloat(0, 20);\n        if (overmind.state.tool.airbrushTool.position) {\n          brushHistory.current.drawDot(ctx, {\n            x: overmind.state.tool.airbrushTool.position.x + radius * Math.cos(angle),\n            y: overmind.state.tool.airbrushTool.position.y + radius * Math.sin(angle),\n          });\n        }\n      }\n      onPaint();\n      this.timeout = setTimeout(draw, 20, ctx, onPaint);\n    };\n\n    this.prepareToPaint(isRightMouseButton(event));\n    this.timeout = setTimeout(draw, 20, ctx, onPaint);\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    const { event, undoPoint } = params;\n    clearTimeout(this.timeout);\n    this.onInit(omit(params, 'event'));\n    if (isLeftOrRightMouseButton(event)) {\n      undoPoint();\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n\nfunction getRandomFloat(min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n","/Users/jani/Code/Web/dxpaint/src/brush/BuiltInBrushFactory.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Throttle.tsx",["396"],"export class Throttle {\n  private milliSecs: number;\n  private lastFunc: NodeJS.Timeout | null;\n  private lastRan: number | null;\n\n  public constructor(milliSecs: number) {\n    this.milliSecs = milliSecs;\n    this.lastFunc = null;\n    this.lastRan = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  public call(func: Function): void {\n    if (!this.lastRan) {\n      func();\n      this.lastRan = Date.now();\n    } else {\n      if (this.lastFunc) {\n        clearTimeout(this.lastFunc);\n      }\n      this.lastFunc = setTimeout(() => {\n        if (Date.now() - this.lastRan! >= this.milliSecs) {\n          func();\n          this.lastRan = Date.now();\n        }\n      }, this.milliSecs - (Date.now() - this.lastRan));\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItemSave.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxDualToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/Debounce.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/tool/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/brush/PixelBrush.tsx",["397","398","399","400","401"],"/Users/jani/Code/Web/dxpaint/src/tools/LineTool.tsx",["402"],"/Users/jani/Code/Web/dxpaint/src/tools/ZoomInitialPointSelectorTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/CurveTool.tsx",["403"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  isLeftOrRightMouseButton,\n  omit,\n} from './util/util';\nimport { Throttle } from './util/Throttle';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class CurveTool implements Tool {\n  private throttle = new Throttle(50);\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.curveToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const endPoint = overmind.state.tool.curveTool.end;\n\n    if (endPoint) {\n      brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos);\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n    } else {\n      overmind.actions.tool.curveToolEnd(mousePos);\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    if (!overmind.state.tool.curveTool.end) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.curveToolStart(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    const startPoint = overmind.state.tool.curveTool.start;\n    if (!startPoint) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    const endPoint = overmind.state.tool.curveTool.end;\n    if (endPoint) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawCurve(ctx, startPoint, endPoint, mousePos);\n      });\n    } else if (isLeftOrRightMouseButton(event)) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawLine(ctx, startPoint, mousePos);\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/PolygonTool.tsx",["404"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  pointEquals,\n  omit,\n} from './util/util';\nimport { overmind } from '../index';\nimport { Throttle } from './util/Throttle';\nimport { unfilledPolygon } from '../algorithm/shape';\nimport { PixelBrush } from '../brush/PixelBrush';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class PolygonTool implements Tool {\n  private throttle = new Throttle(20);\n  public constructor(filled: boolean) {\n    this.filled = filled;\n  }\n  private filled: boolean;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.polygonToolReset();\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      undoPoint,\n      onPaint,\n    } = params;\n    const mousePos = getMousePos(canvas, event);\n\n    // first click (left or right) determines polygon fill color\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      this.prepareToPaint(isRightMouseButton(event));\n      overmind.actions.tool.polygonToolAddVertice(mousePos);\n      return;\n    }\n\n    // complete polygon on right click or if starting point reselected\n    if (\n      isRightMouseButton(event) ||\n      pointEquals(overmind.state.tool.polygonTool.vertices[0], mousePos)\n    ) {\n      if (this.filled) {\n        brushHistory.current.drawFilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(ctx, overmind.state.tool.polygonTool.vertices);\n      }\n      undoPoint();\n      onPaint();\n      this.onInit(omit(params, 'event'));\n      return;\n    }\n\n    // otherwise just add new vertice\n    overmind.actions.tool.polygonToolAddVertice(mousePos);\n  }\n\n  // Overlay\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 1) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n    }\n    onPaint();\n  }\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n\n    if (!overmind.state.tool.polygonTool.vertices.length) {\n      clearOverlayCanvas(canvas);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    if (this.filled) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        unfilledPolygon(\n          ctx,\n          new PixelBrush(),\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    } else {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices.slice().concat(mousePos),\n          false\n        );\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    clearOverlayCanvas(canvas);\n\n    if (overmind.state.tool.polygonTool.vertices.length > 0) {\n      if (this.filled) {\n        unfilledPolygon(ctx, new PixelBrush(), overmind.state.tool.polygonTool.vertices, false);\n      } else {\n        brushHistory.current.drawUnfilledPolygon(\n          ctx,\n          overmind.state.tool.polygonTool.vertices,\n          false\n        );\n      }\n      onPaint();\n    }\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/components/dialog/Dialog.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/MainCanvas.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/CanvasState.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/hooks.tsx",["405","406"],"import { Point } from '../../types';\nimport { useEffect } from 'react';\nimport { useOvermind } from '../../overmind';\nimport { undoBuffer } from '../../overmind/undo/UndoBuffer';\nimport { blobToCanvas } from './util';\nimport { EventHandlerParams, EventHandlerParamsOverlay } from '../../tools/Tool';\n//import { renderToCanvasFrom } from '../../colorIndex/ColorIndexer';\n\nexport function useInitTool(\n  eventHandlerParams: EventHandlerParams,\n  eventHandlerParamsOverlay: EventHandlerParamsOverlay,\n  isZoomCanvas: boolean\n): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.previousTool?.onExit?.(eventHandlerParams);\n      state.toolbox.previousTool?.onExitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.previousTool]);\n  useEffect((): void => {\n    if (!isZoomCanvas) {\n      state.toolbox.activeTool.onInit?.(eventHandlerParams);\n      state.toolbox.activeTool.onInitOverlay?.(eventHandlerParamsOverlay);\n    }\n  }, [state.toolbox.activeTool]);\n}\n\n// Update current fillStyle from state to canvas context when:\n// 1. fillStyle has been changed\n// 2. canvas resolution changes, as this also resets context\nexport function useFillStyle(ctx: CanvasRenderingContext2D | null): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    if (ctx) {\n      ctx.fillStyle = state.canvas.fillStyle;\n      ctx.strokeStyle = state.canvas.fillStyle;\n    }\n  }, [state.canvas.fillStyle, state.canvas.resolution]);\n}\n\nexport function useUndo(canvas: HTMLCanvasElement): void {\n  const { state } = useOvermind();\n  useEffect((): void => {\n    //blobToCanvas(state.undo.currentBufferItem, canvas);\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (state.undo.currentIndex === null) {\n        return;\n      }\n      const colorIndex = undoBuffer.getItem(state.undo.currentIndex);\n      //renderToCanvasFrom(ctx, colorIndex);\n    }\n    console.log('undo hook end');\n  }, [state.undo.lastUndoRedoTime]);\n}\n\n// Load image to canvas when loadedImageURL changes\n// Changes canvas height and width to match image\nexport function useLoadedImage(canvas: HTMLCanvasElement): void {\n  const { state, actions } = useOvermind();\n  useEffect((): void => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n    const image = new Image();\n    image.onload = function (): void {\n      // No need to clear canvas, as changing dimensions clears it anyway.\n      // Note that context is also reset\n      actions.canvas.setResolution({ width: image.width, height: image.height });\n      ctx.drawImage(image, 0, 0);\n      actions.undo.setUndoPoint(canvas);\n      actions.canvas.setCanvasModified(false);\n    };\n    image.src = state.canvas.loadedImageURL;\n  }, [state.canvas.loadedImageURL]);\n}\n\nexport function useScrollToFocusPoint(\n  canvasDiv: HTMLDivElement,\n  focusPoint: Point | null,\n  zoomFactor = 1\n): void {\n  useEffect((): void => {\n    if (focusPoint === null) {\n      return;\n    }\n    const scrollOptions = {\n      left: focusPoint.x * zoomFactor - canvasDiv.clientWidth / 2,\n      top: focusPoint.y * zoomFactor - canvasDiv.clientHeight / 2,\n    };\n    canvasDiv.scrollTo(scrollOptions);\n  }, [focusPoint]);\n}\n","/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxToggleButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/paletteEditor/PaletteEditor.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/GlobalHotkeyManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/Toolbox.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/dialog/DialogManager.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/palette/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/MenuItem.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/toolbox/buttons/ToolboxActionButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/brush/actions.ts",["407","408"],"import { Action } from 'overmind';\nimport { BrushInterface } from '../../brush/Brush';\nimport { Mode, BuiltInBrushId, builtInBrushes } from './state';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { brushHistory } from '../../brush/BrushHistory';\n\nexport const setBrush: Action<BrushInterface> = ({ state }, brush): void => {\n  brushHistory.set(brush);\n};\n\nexport const selectBuiltInBrush: Action<BuiltInBrushId> = (\n  { state, actions },\n  brushNumber\n): void => {\n  state.brush.selectedBuiltInBrushId = brushNumber;\n  actions.brush.setBrush(builtInBrushes[brushNumber]);\n  actions.brush.setMode('Color');\n};\n\nexport const setMode: Action<Mode> = ({ state }, mode): void => {\n  state.brush.mode = mode;\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    if (mode === 'Color') {\n      brush.setFGColor(state.palette.foregroundColor);\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toFGColor();\n    } else if (mode === 'Matte') {\n      brush.setBGColor(state.palette.backgroundColor);\n      brush.toMatte();\n    }\n  }\n};\n\nexport const toFGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (state.brush.mode === 'Color' && brush instanceof CustomBrush) {\n    brush.toFGColor();\n  }\n  if (state.brush.mode === 'Matte' && brush instanceof CustomBrush) {\n    brush.toMatte();\n  }\n};\n\nexport const toBGBrush: Action = ({ state }): void => {\n  const brush = brushHistory.current;\n  if (brush instanceof CustomBrush) {\n    brush.toBGColor();\n  }\n};\n","/Users/jani/Code/Web/dxpaint/src/tools/BrushSelector.tsx",["409"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport { getMousePos, clearOverlayCanvas, extractBrush } from './util/util';\nimport { overmind } from '../index';\nimport { selection } from './util/SelectionIndicator';\n\nexport class BrushSelector implements Tool {\n  public onInit(params: EventHandlerParams): void {\n    const {\n      ctx: { canvas },\n    } = params;\n    overmind.actions.tool.brushSelectionStart(null);\n    selection.prepare(canvas);\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      return;\n    }\n\n    const mousePos = getMousePos(canvas, event);\n    const width = mousePos.x - start.x;\n    const height = mousePos.y - start.y;\n\n    const brush = extractBrush(canvas, start, width, height);\n    overmind.actions.brush.setBrush(brush);\n    overmind.actions.brush.setMode('Matte');\n\n    // exit brush selection tool\n    overmind.actions.toolbox.toggleBrushSelectionMode();\n    // switch to Dotted Freehand tool after selection\n    overmind.actions.toolbox.setSelectedDrawingTool('dottedFreehand');\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const { event, ctx } = params;\n    const mousePos = getMousePos(ctx.canvas, event);\n    overmind.actions.tool.brushSelectionStart(mousePos);\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    overmind.actions.tool.brushSelectionStart(null);\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n\n    const start = overmind.state.tool.brushSelectorTool.start;\n    if (!start) {\n      selection.edgeToEdgeCrosshair(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    selection.box(ctx, start, mousePos);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseUpOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/CircleTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/ColorSelectorTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/SelectionIndicator.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/dialog/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/canvas/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/RectangleTool.tsx",["410"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport { getMousePos, clearOverlayCanvas, isRightMouseButton, omit } from './util/util';\nimport { Throttle } from './util/Throttle';\nimport { selection } from './util/SelectionIndicator';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\nimport { paintingCanvasController } from '../core/PaintingCanvasController';\nimport { overlayCanvasController } from '../core/OverlayCanvasController';\n\nexport class RectangleTool implements Tool {\n  private throttle = new Throttle(50);\n\n  public constructor(filled: boolean) {\n    this.filled = filled;\n  }\n  private filled: boolean;\n\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    const {\n      ctx: { canvas },\n    } = params;\n    selection.prepare(canvas);\n    overmind.actions.tool.rectangleToolStart(null);\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n      undoPoint,\n    } = params;\n\n    const startPoint = overmind.state.tool.rectangleTool.start;\n    if (!startPoint) {\n      return;\n    }\n\n    const endPoint = getMousePos(canvas, event);\n\n    if (this.filled) {\n      brushHistory.current.drawFilledRect(ctx, startPoint, endPoint, paintingCanvasController);\n    } else {\n      brushHistory.current.drawUnfilledRect(ctx, startPoint, endPoint);\n    }\n    undoPoint();\n    onPaint();\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    this.prepareToPaint(isRightMouseButton(event));\n    const mousePos = getMousePos(canvas, event);\n    overmind.actions.tool.rectangleToolStart(mousePos);\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    if (!event.buttons) {\n      this.onInit(omit(params, 'event'));\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n\n    const startPoint = overmind.state.tool.rectangleTool.start;\n    if (!startPoint) {\n      clearOverlayCanvas(canvas);\n      if (!this.filled) {\n        // DPaint only draws unfilled shapes with the current brush\n        brushHistory.current.drawDot(ctx, mousePos);\n      }\n      selection.edgeToEdgeCrosshair(ctx, mousePos);\n      onPaint();\n      return;\n    }\n\n    if (this.filled) {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawFilledRect(ctx, startPoint, mousePos);\n      });\n    } else {\n      this.throttle.call((): void => {\n        clearOverlayCanvas(canvas);\n        brushHistory.current.drawUnfilledRect(ctx, startPoint, mousePos);\n      });\n    }\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseUpOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/tools/TextTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/index.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/toolbox/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/tools/DottedFreehandTool.tsx",["411"],"import {\n  Tool,\n  EventHandlerParamsWithEvent,\n  OverlayEventHandlerParamsWithEvent,\n  EventHandlerParams,\n} from './Tool';\nimport {\n  getMousePos,\n  clearOverlayCanvas,\n  isRightMouseButton,\n  omit,\n  isLeftOrRightMouseButton,\n} from './util/util';\nimport { overmind } from '../index';\nimport { brushHistory } from '../brush/BrushHistory';\n\nexport class DottedFreehandTool implements Tool {\n  private prepareToPaint(withBGColor: boolean): void {\n    if (withBGColor) {\n      overmind.actions.tool.activeToolToBGFillStyle();\n      overmind.actions.brush.toBGBrush();\n    }\n  }\n\n  public onInit(params: EventHandlerParams): void {\n    overmind.actions.tool.activeToolToFGFillStyle();\n    overmind.actions.brush.toFGBrush();\n  }\n\n  public onContextMenu(params: EventHandlerParamsWithEvent): void {\n    const { event } = params;\n    event.preventDefault();\n  }\n\n  public onMouseMove(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    if (event.buttons) {\n      const mousePos = getMousePos(canvas, event);\n      brushHistory.current.drawDot(ctx, mousePos);\n      onPaint();\n    }\n  }\n\n  public onMouseDown(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n\n    const mousePos = getMousePos(canvas, event);\n    this.prepareToPaint(isRightMouseButton(event));\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseUp(params: EventHandlerParamsWithEvent): void {\n    const { undoPoint } = params;\n    this.onInit(omit(params, 'event'));\n    undoPoint();\n  }\n\n  public onMouseLeave(params: EventHandlerParamsWithEvent): void {\n    this.onInit(omit(params, 'event'));\n  }\n\n  public onMouseEnter(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx: { canvas },\n    } = params;\n    if (isLeftOrRightMouseButton(event)) {\n      this.prepareToPaint(isRightMouseButton(event));\n      const mousePos = getMousePos(canvas, event);\n      overmind.actions.tool.freeHandToolPrevious(mousePos);\n    }\n  }\n\n  // Overlay\n\n  public onMouseMoveOverlay(params: EventHandlerParamsWithEvent): void {\n    const {\n      event,\n      ctx,\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    if (event.buttons) {\n      return;\n    }\n    clearOverlayCanvas(canvas);\n\n    const mousePos = getMousePos(canvas, event);\n    brushHistory.current.drawDot(ctx, mousePos);\n    onPaint();\n  }\n\n  public onMouseDownOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n\n  public onMouseLeaveOverlay(params: OverlayEventHandlerParamsWithEvent): void {\n    const {\n      ctx: { canvas },\n      onPaint,\n    } = params;\n    clearOverlayCanvas(canvas);\n    onPaint();\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/ColorButton.tsx",[],"/Users/jani/Code/Web/dxpaint/src/components/palette/Palette.tsx",[],"/Users/jani/Code/Web/dxpaint/src/algorithm/primitive.ts",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/util.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/actions.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/menubar/Menubar.tsx",[],"/Users/jani/Code/Web/dxpaint/src/tools/util/util.tsx",["412","413","414"],"import { Point, Color } from '../../types';\nimport { Tool, EventHandlerParams, EventHandlerParamsOverlay } from '../Tool';\nimport { CustomBrush } from '../../brush/CustomBrush';\nimport { overmind } from '../../index';\n\nexport function colorToRGBString(color: Color): string {\n  return 'rgb(' + color.r + ',' + color.g + ',' + color.b + ')';\n}\n\nexport function getMousePos(\n  canvas: HTMLCanvasElement,\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): Point {\n  const rect = canvas.getBoundingClientRect(), // abs. size of element\n    scaleX = canvas.width / rect.width, // relationship bitmap vs. element for X\n    scaleY = canvas.height / rect.height; // relationship bitmap vs. element for Y\n\n  return {\n    x: Math.floor((event.clientX - rect.left) * scaleX), // scale mouse coordinates after they have\n    y: Math.floor((event.clientY - rect.top) * scaleY), // been adjusted to be relative to element\n  };\n}\n\nexport function pointEquals(point1: Point, point2: Point): boolean {\n  return point1.x === point2.x && point1.y === point2.y;\n}\n\nexport function points8Connected(point1: Point, point2: Point): boolean {\n  return Math.abs(point1.x - point2.x) <= 1 && Math.abs(point1.y - point2.y) <= 1;\n}\n\nexport function clearCanvas(canvas: HTMLCanvasElement, color: Color): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n  ctx.rect(0, 0, canvas.width, canvas.height);\n  const oldFillStyle = ctx.fillStyle;\n  ctx.fillStyle = colorToRGBString(color);\n  ctx.fill();\n  ctx.fillStyle = oldFillStyle;\n}\n\nexport function clearOverlayCanvas(canvas: HTMLCanvasElement): void {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nexport function getEventHandler(\n  tool: Tool,\n  eventHandlerName:\n    | 'onClick'\n    | 'onContextMenu'\n    | 'onMouseMove'\n    | 'onMouseUp'\n    | 'onMouseDown'\n    | 'onMouseLeave'\n    | 'onMouseEnter',\n  eventHandlerParams: EventHandlerParams\n): (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void {\n  if (hasKey(tool, eventHandlerName)) {\n    return (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): void =>\n      tool[eventHandlerName]!({ event: event, ...eventHandlerParams });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  return (): void => {};\n}\n\nexport function getEventHandlerOverlay(\n  tool: Tool,\n  eventHandlerName:\n    | 'onMouseMoveOverlay'\n    | 'onMouseLeaveOverlay'\n    | 'onMouseEnterOverlay'\n    | 'onMouseUpOverlay'\n    | 'onMouseDownOverlay'\n    | 'onClickOverlay',\n  eventHandlerParams: EventHandlerParamsOverlay\n): (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void {\n  if (hasKey(tool, eventHandlerName)) {\n    return (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): void =>\n      tool[eventHandlerName]!({ event: event, ...eventHandlerParams });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  return (): void => {};\n}\n\nfunction hasKey<O>(obj: O, key: keyof any): key is keyof O {\n  return key in obj;\n}\n\nexport function isRightMouseButton(\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): boolean {\n  return event.button === 2 || event.buttons === 2;\n}\n\nexport function isLeftMouseButton(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>): boolean {\n  return event.button === 1 || event.buttons === 1;\n}\n\nexport function isLeftOrRightMouseButton(\n  event: React.MouseEvent<HTMLCanvasElement, MouseEvent>\n): boolean {\n  return isLeftMouseButton(event) || isRightMouseButton(event);\n}\n\n// eslint-disable-next-line max-len\n// adapted from https://stackoverflow.com/questions/11472273/how-to-edit-pixels-and-remove-white-background-in-a-canvas-image-in-html5-and-ja\nexport function extractBrush(\n  sourceCanvas: HTMLCanvasElement,\n  start: Point,\n  width: number,\n  height: number\n): CustomBrush {\n  const bufferCanvas = document.createElement('canvas');\n\n  bufferCanvas.width = Math.abs(width);\n  bufferCanvas.height = Math.abs(height);\n\n  const bufferCanvasCtx = bufferCanvas.getContext('2d');\n  if (!bufferCanvasCtx) {\n    throw 'Error retrieving Context for buffer Canvas while extracting brush';\n  }\n\n  bufferCanvasCtx.drawImage(\n    sourceCanvas,\n    start.x,\n    start.y,\n    width,\n    height,\n    0,\n    0,\n    bufferCanvas.width,\n    bufferCanvas.height\n  );\n\n  const backgroundColor =\n    overmind.state.palette.backgroundColor.r * 0x00000001 +\n    overmind.state.palette.backgroundColor.g * 0x00000100 +\n    overmind.state.palette.backgroundColor.b * 0x00010000 +\n    255 * 0x01000000;\n\n  const imageData = bufferCanvasCtx.getImageData(0, 0, bufferCanvas.width, bufferCanvas.height);\n  const imageDataBufferTMP = new ArrayBuffer(imageData.data.length);\n  const imageDataClamped8TMP = new Uint8ClampedArray(imageDataBufferTMP);\n  const imageDataUint32TMP = new Uint32Array(imageDataBufferTMP);\n\n  imageDataClamped8TMP.set(imageData.data);\n\n  let n = imageDataUint32TMP.length;\n  while (n--) {\n    if (imageDataUint32TMP[n] === backgroundColor) {\n      imageDataUint32TMP[n] = 0x00000000; // make it transparent\n    }\n  }\n\n  imageData.data.set(imageDataClamped8TMP);\n  bufferCanvasCtx.putImageData(imageData, 0, 0);\n\n  // Extract color index and add tansparency for background color\n\n  //const colorIndex = colorIndexer.getAreaFromIndex(start.x, start.y, width, height);\n  const colorIndex = new Uint8Array(); // TODO\n  if (!colorIndex) {\n    throw 'Error retrieving color index for new brush';\n  }\n  const colorIndexWithTransparency = addTransparency(\n    colorIndex,\n    Number(overmind.state.palette.backgroundColorId)\n  );\n\n  return new CustomBrush(bufferCanvas.toDataURL(), colorIndexWithTransparency);\n}\n\nexport function addTransparency(texture: Uint8Array, transparentColorIndex: number): Uint8Array {\n  return texture.map((item) => (item === transparentColorIndex ? 0 : item));\n}\n\ninterface Omit {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  <T extends object, K extends [...(keyof T)[]]>(obj: T, ...keys: K): {\n    [K2 in Exclude<keyof T, K[number]>]: T[K2];\n  };\n}\n\nexport const omit: Omit = (obj, ...keys) => {\n  const ret = {} as {\n    [K in keyof typeof obj]: typeof obj[K];\n  };\n  let key: keyof typeof obj;\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n};\n","/Users/jani/Code/Web/dxpaint/src/overmind/paletteEditor/index.ts",[],[],"/Users/jani/Code/Web/dxpaint/src/overmind/app/state.ts",[],"/Users/jani/Code/Web/dxpaint/src/overmind/undo/UndoBuffer.ts",[],"/Users/jani/Code/Web/dxpaint/src/components/canvas/util.tsx",[],"/Users/jani/Code/Web/dxpaint/src/serviceWorker.ts",["415","416"],"/Users/jani/Code/Web/dxpaint/src/tools/FloodFillTool.tsx",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/DrawImageIndexer.ts",[],"/Users/jani/Code/Web/dxpaint/src/colorIndex/ColorIndexer.ts",["417","418"],"import { GeometricIndexer } from './indexers/GeometricIndexer';\nimport { DrawImageIndexer } from './indexers/DrawImageIndexer';\nimport { CustomBrush } from '../brush/CustomBrush';\nimport { overmind } from '../index';\nimport { Line, Point } from '../types';\nimport { visualiseTexture } from './util';\n\nexport class ColorIndexer {\n  private gl: WebGLRenderingContext;\n  private geometricIndexer: GeometricIndexer;\n  private drawImageIndexer: DrawImageIndexer;\n\n  constructor() {\n    this.gl = this.createIndexerGLContext(0, 0, 0);\n\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n  }\n\n  private createIndexerGLContext(\n    width: number,\n    height: number,\n    backgroundColorId: number\n  ): WebGLRenderingContext {\n    // init a webgl context for a canvas element outside the DOM\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const gl = canvas.getContext('webgl', {\n      preserveDrawingBuffer: true,\n      antialias: false,\n    });\n\n    if (!gl) {\n      alert('Sorry, ReDPaint requires WebGL support:(');\n      throw 'Sorry, ReDPaint requires WebGL support';\n    }\n    return gl;\n  }\n\n  init(): void {\n    const width = overmind.state.canvas.resolution.width;\n    const height = overmind.state.canvas.resolution.height;\n    const backgroundColorId = Number(overmind.state.palette.backgroundColorId);\n    console.log(`ColorIndexer init, width=${width}, heigth=${height}`);\n    this.gl = this.createIndexerGLContext(width, height, backgroundColorId);\n\n    // create indexers\n\n    this.geometricIndexer = new GeometricIndexer(this.gl);\n    this.drawImageIndexer = new DrawImageIndexer(this.gl);\n  }\n\n  fillRect(start: Point, end: Point, colorIndex: number): void {\n    this.geometricIndexer.indexFillRect(start, end, colorIndex);\n  }\n\n  points(points: Point[], colorIndex: number): void {\n    this.geometricIndexer.indexPoints(points, colorIndex);\n  }\n\n  lines(lines: Line[], colorIndex: number): void {\n    this.geometricIndexer.indexLines(lines, colorIndex);\n  }\n\n  drawImage(x: number, y: number, brush: CustomBrush): void {\n    this.drawImageIndexer.indexDrawImage(x, y, brush);\n  }\n\n  getIndexAsCanvas(): HTMLCanvasElement | OffscreenCanvas {\n    return this.gl.canvas;\n  }\n\n  getIndex(): Uint8Array {\n    const pixels = new Uint8Array(this.gl.drawingBufferHeight * this.gl.drawingBufferWidth * 4);\n    this.gl.readPixels(\n      0,\n      0,\n      this.gl.drawingBufferWidth,\n      this.gl.drawingBufferHeight,\n      this.gl.RGBA,\n      this.gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  resetIndex(): void {\n    /* const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    // initialize the color index matrix with the background color\n    const backgroundColor = Number(overmind.state.palette.backgroundColorId);\n    const data = new Uint8Array(gl.drawingBufferHeight * gl.drawingBufferWidth * 4).fill(\n      backgroundColor\n    );\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      data\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n    */\n  }\n\n  setIndex(index: Uint8Array | null): void {\n    /* if (!index) {\n      return;\n    }\n\n    const gl = this.gl;\n\n    // create a texture to render to\n\n    const targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const targetTextureWidth = gl.drawingBufferWidth;\n    const targetTextureHeight = gl.drawingBufferHeight;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      targetTextureWidth,\n      targetTextureHeight,\n      border,\n      format,\n      type,\n      index\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // create and bind the framebuffer\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\n    // attach the texture as the first color attachment\n\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\n    */\n  }\n\n  getAreaFromIndex(\n    x: number, // canvas coord (origin upper left corner)\n    y: number, // canvas coord (origin upper left corner)\n    width: number, // canvas coord, can be negative\n    height: number // canvas coord, can be negative\n  ): Uint8Array | undefined {\n    const gl = this.gl;\n\n    // for readPixels we need to define the area with:\n    // - lower left corner of the area and\n    // - width and height as positive integers\n    // Texture coordinates\n\n    let rectLowerLeftX: number;\n    let rectLowerLeftY: number;\n\n    if (width < 0) {\n      rectLowerLeftX = x - Math.abs(width);\n    } else {\n      rectLowerLeftX = x;\n    }\n\n    if (height < 0) {\n      rectLowerLeftY = gl.drawingBufferHeight - y;\n    } else {\n      rectLowerLeftY = gl.drawingBufferHeight - y - Math.abs(height);\n    }\n\n    const pixels = new Uint8Array(Math.abs(width) * Math.abs(height) * 4);\n    console.log('canvas: x:' + x + ' y: ' + y + ' w: ' + width + ' h: ' + height);\n    console.log(\n      'texture: x:' +\n        rectLowerLeftX +\n        ' y: ' +\n        rectLowerLeftY +\n        ' w: ' +\n        Math.abs(width) +\n        ' h: ' +\n        Math.abs(height)\n    );\n    console.log('gl.drawingBufferHeight: ' + gl.drawingBufferHeight);\n    gl.readPixels(\n      rectLowerLeftX,\n      rectLowerLeftY,\n      Math.abs(width),\n      Math.abs(height),\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    return pixels;\n  }\n\n  getColorIndexForPixel(point: Point): number | undefined {\n    const colorIndex = this.getAreaFromIndex(point.x, point.y, 1, 1);\n    return colorIndex?.[0];\n  }\n\n  // testing, debugging purposes only\n  visualiseIndex(): void {\n    const index = this.getIndex();\n    const width = this.gl.drawingBufferWidth;\n    visualiseTexture(index, width);\n  }\n}\n\n//export const colorIndexer = new ColorIndexer();\n","/Users/jani/Code/Web/dxpaint/src/colorIndex/indexers/GeometricIndexer.ts",["419"],"/Users/jani/Code/Web/dxpaint/src/renderer/PaintingCanvasRenderController.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexDrawImageRenderer.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/renderers/ColorIndexGeometricRenderer.ts",["420"],"/* eslint-disable max-len */\nimport { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../../colorIndex/util';\nimport { paintingCanvasController } from '../../core/PaintingCanvasController';\n\nexport class ColorIndexGeometricRenderer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public renderPoints(points: Point[]): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // update color index texture\n\n    /* gl.activeTexture(gl.TEXTURE0);\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    const indexCanvas = colorIndexer.getIndexAsCanvas();\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, indexCanvas); */\n\n    gl.activeTexture(gl.TEXTURE0);\n    const level = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    const indexCanvas = paintingCanvasController.colorIndexer?.getIndexAsCanvas();\n    if (!indexCanvas) {\n      throw 'no indexcanvas';\n    }\n    gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, format, type, indexCanvas);\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    const resolution = gl.getUniformLocation(this.program, 'resolution');\n    this.gl.uniform2f(resolution, gl.canvas.width, gl.canvas.height);\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public renderLines(lines: Line[]): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // update color index texture\n\n    /*     gl.activeTexture(gl.TEXTURE0);\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    const indexCanvas = colorIndexer.getIndexAsCanvas();\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, indexCanvas); */\n\n    /*     gl.activeTexture(gl.TEXTURE0);\n    const level = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    const indexCanvas = colorIndexer.getIndexAsCanvas();\n    gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, format, type, indexCanvas); */\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    const resolution = gl.getUniformLocation(this.program, 'resolution');\n    this.gl.uniform2f(resolution, gl.canvas.width, gl.canvas.height);\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform vec2 resolution;\n    uniform sampler2D u_image;\n    uniform sampler2D u_palette;\n\n    void main() {\n      vec2 position = vec2((gl_FragCoord.x) / (resolution.x), 1.0 - (gl_FragCoord.y / (resolution.y)));\n      float index = texture2D(u_image, position).r * 255.0 - 1.0;\n      /*\n      if (index < 0.1) {\n        gl_FragColor = vec4(1,1,1,1);\n      }\n      else {\n        gl_FragColor = texture2D(u_palette, vec2((index + 0.5) / 256.0, 0.5));\n      }\n      */\n      gl_FragColor = texture2D(u_palette, vec2((index + 0.5) / 256.0, 0.5));\n      //gl_FragColor = vec4(1,1,1,1);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile the program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n\n    // tell it to use texture units 0 and 1 for the image and palette\n\n    const imageLoc = gl.getUniformLocation(program, 'u_image');\n    const paletteLoc = gl.getUniformLocation(program, 'u_palette');\n    gl.uniform1i(imageLoc, 0);\n    gl.uniform1i(paletteLoc, 1);\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n\n    console.log('Program ready (GeometricRenderer)');\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/core/OverlayCanvasController.ts",["421"],"import { CustomBrush } from '../brush/CustomBrush';\nimport { Line, Point } from '../types';\nimport { OverlayCanvasRenderController } from '../renderer/OverlayCanvasRenderController';\nimport { CanvasController } from './CanvasController';\n\n// OverlayController is a singleton responsible for controlling\n// the two overlay canvases in the app for MainCanvas and ZoomCanvas.\nclass OverlayController implements CanvasController {\n  private mainCanvasOverlay: HTMLCanvasElement;\n  private zoomCanvasOverlay: HTMLCanvasElement;\n  private zoomCanvasOverlayCtx: CanvasRenderingContext2D | null = null;\n  private mainCanvasOverlayRenderer: OverlayCanvasRenderController | null = null;\n  //private zoomCanvasOverlayRenderer: OverlayCanvasRenderController | null = null;\n\n  constructor() {\n    this.mainCanvasOverlay = document.createElement('canvas');\n    this.zoomCanvasOverlay = document.createElement('canvas');\n  }\n\n  attachMainCanvas(mainCanvasOverlay: HTMLCanvasElement): void {\n    this.mainCanvasOverlay = mainCanvasOverlay;\n    this.mainCanvasOverlayRenderer = new OverlayCanvasRenderController(mainCanvasOverlay);\n  }\n\n  attachZoomCanvas(zoomCanvasOverlay: HTMLCanvasElement): void {\n    this.zoomCanvasOverlay = zoomCanvasOverlay;\n    this.zoomCanvasOverlayCtx = zoomCanvasOverlay.getContext('2d', {\n      alpha: true,\n      desynchronized: false,\n    });\n    //this.zoomCanvasOverlayRenderer = new OverlayCanvasRenderController(zoomCanvasOverlay);\n  }\n\n  /*   fillRect(x: number, y: number, width: number, heigth: number, colorIndex: number): void {\n    colorIndexer.fillRect(x, y, width, heigth, colorIndex);\n    console.log('fillrect');\n    //this.render();\n  } */\n\n  points(points: Point[], colorIndex: number): void {\n    this.mainCanvasOverlayRenderer?.points(points, colorIndex);\n    this.mainCanvasOverlayRenderer?.renderTo2dCanvas(this.zoomCanvasOverlayCtx);\n    //this.zoomCanvasOverlayRenderer?.points(points, colorIndex);\n    //this.render();\n  }\n\n  lines(lines: Line[], colorIndex: number): void {\n    this.mainCanvasOverlayRenderer?.lines(lines, colorIndex);\n    this.mainCanvasOverlayRenderer?.renderTo2dCanvas(this.zoomCanvasOverlayCtx);\n    //this.zoomCanvasOverlayRenderer?.lines(lines, colorIndex);\n    //this.render();\n  }\n\n  /*   drawImage(x: number, y: number, brush: CustomBrush): void {\n    colorIndexer.drawImage(x, y, brush);\n    this.render();\n  }\n\n  render(): void {\n    this.mainCanvasRenderer?.renderCanvas();\n    this.zoomCanvasRenderer?.renderCanvas();\n  } */\n}\n\nexport const overlayCanvasController = new OverlayController();\n","/Users/jani/Code/Web/dxpaint/src/renderer/renderers/OverlayGeometricRenderer.ts",["422"],"/* eslint-disable max-len */\nimport { Line, Point } from '../../types';\nimport {\n  canvasToWebGLCoordInvert,\n  canvasToWebGLCoordX,\n  canvasToWebGLCoordY,\n  shiftLine,\n  shiftPoint,\n} from '../../colorIndex/util';\nimport { overmind } from '../..';\n\nexport class OverlayGeometricRenderer {\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram | null = null;\n  private currentColorIndex = 0;\n\n  public constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.initShaders();\n  }\n\n  public renderPoints(points: Point[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * points.length);\n    for (let i = 0; i < points.length; i++) {\n      const shiftedPoint = shiftPoint(points[i]);\n      vertices[i * 2] = canvasToWebGLCoordX(gl, shiftedPoint.x);\n      vertices[i * 2 + 1] = canvasToWebGLCoordInvert(gl, shiftedPoint.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.POINTS, 0, points.length);\n  }\n\n  public renderLines(lines: Line[], colorIndex: number): void {\n    const gl = this.gl;\n\n    if (!this.program) {\n      return;\n    }\n    if (gl.getParameter(gl.CURRENT_PROGRAM) !== this.program) {\n      console.log('switching webgl program GeometricRenderer');\n      gl.useProgram(this.program);\n    }\n\n    this.updateColor(colorIndex);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    const vertices = new Float32Array(2 * 2 * lines.length);\n    for (let i = 0; i < lines.length; i++) {\n      const shiftedLine = shiftLine(lines[i]);\n      vertices[i * 4] = canvasToWebGLCoordX(gl, shiftedLine.p1.x);\n      vertices[i * 4 + 1] = canvasToWebGLCoordInvert(gl, shiftedLine.p1.y);\n      vertices[i * 4 + 2] = canvasToWebGLCoordX(gl, shiftedLine.p2.x);\n      vertices[i * 4 + 3] = canvasToWebGLCoordInvert(gl, shiftedLine.p2.y);\n    }\n\n    this.gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);\n    this.gl.drawArrays(gl.LINES, 0, 2 * lines.length);\n  }\n\n  private updateColor(colorIndex: number) {\n    if (colorIndex == this.currentColorIndex) {\n      return;\n    }\n\n    if (!this.program) {\n      return;\n    }\n    const gl = this.gl;\n\n    console.log('updating color uniform');\n    this.currentColorIndex = colorIndex;\n    const color = overmind.state.palette.paletteArray[colorIndex - 1];\n    const u_color = gl.getUniformLocation(this.program, 'u_color');\n    gl.uniform3f(u_color, color.r, color.g, color.b);\n  }\n\n  private initShaders(): void {\n    const vertexShader = `\n    attribute vec4 a_Position;\n\n    void main () {\n      gl_Position = a_Position;\n      gl_PointSize = 1.0;\n    }\n    `;\n\n    const fragmentShader = `\n    precision mediump float;\n\n    uniform vec3 u_color;\n\n    void main () {\n      gl_FragColor = vec4(u_color.x/255.0, u_color.y/255.0, u_color.z/255.0, 1.0);\n    }\n    `;\n\n    const gl = this.gl;\n\n    const vs = gl.createShader(gl.VERTEX_SHADER);\n    if (!vs) {\n      return;\n    }\n    gl.shaderSource(vs, vertexShader);\n    gl.compileShader(vs);\n\n    // Catch some possible errors on vertex shader\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(vs));\n    }\n\n    const fs = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fs) {\n      return;\n    }\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(fs);\n\n    // Catch some possible errors on fragment shader\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(fs));\n    }\n\n    // Compile to program\n    const program = gl.createProgram();\n    if (!program) {\n      return;\n    }\n    this.program = program;\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    // Catch some possible errors on program\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(gl.getProgramInfoLog(program));\n    }\n    console.log('Program ready (FillRectIndexer)');\n\n    // Create a buffer object for vertex coordinates\n    const vertexBuffer = gl.createBuffer();\n    if (!vertexBuffer) {\n      console.log('Failed to create the buffer object ');\n      return;\n    }\n\n    // Bind the buffer object to target\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n    const a_Position = gl.getAttribLocation(program, 'a_Position');\n\n    // Assign the buffer object to a_Position variable\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);\n\n    // Enable the assignment to a_Position variable\n    gl.enableVertexAttribArray(a_Position);\n  }\n}\n","/Users/jani/Code/Web/dxpaint/src/core/PaintingCanvasController.ts",[],"/Users/jani/Code/Web/dxpaint/src/renderer/OverlayCanvasRenderController.ts",[],{"ruleId":"423","severity":1,"message":"424","line":55,"column":10,"nodeType":"425","messageId":"426","endLine":55,"endColumn":20},{"ruleId":"423","severity":1,"message":"424","line":64,"column":10,"nodeType":"425","messageId":"426","endLine":64,"endColumn":27},{"ruleId":"427","severity":1,"message":"428","line":29,"column":17,"nodeType":"429","messageId":"430","endLine":29,"endColumn":43},{"ruleId":"427","severity":1,"message":"428","line":27,"column":17,"nodeType":"429","messageId":"430","endLine":27,"endColumn":43},{"ruleId":"431","severity":2,"message":"432","line":50,"column":59,"nodeType":"429","messageId":"433","endLine":50,"endColumn":67},{"ruleId":"423","severity":1,"message":"424","line":22,"column":26,"nodeType":"425","messageId":"426","endLine":22,"endColumn":39},{"ruleId":"427","severity":1,"message":"434","line":4,"column":3,"nodeType":"429","messageId":"430","endLine":4,"endColumn":7},{"ruleId":"427","severity":1,"message":"435","line":6,"column":3,"nodeType":"429","messageId":"430","endLine":6,"endColumn":17},{"ruleId":"427","severity":1,"message":"436","line":7,"column":3,"nodeType":"429","messageId":"430","endLine":7,"endColumn":15},{"ruleId":"427","severity":1,"message":"437","line":8,"column":3,"nodeType":"429","messageId":"430","endLine":8,"endColumn":13},{"ruleId":"427","severity":1,"message":"438","line":20,"column":10,"nodeType":"429","messageId":"430","endLine":20,"endColumn":21},{"ruleId":"427","severity":1,"message":"428","line":31,"column":17,"nodeType":"429","messageId":"430","endLine":31,"endColumn":43},{"ruleId":"427","severity":1,"message":"428","line":28,"column":17,"nodeType":"429","messageId":"430","endLine":28,"endColumn":43},{"ruleId":"427","severity":1,"message":"428","line":34,"column":17,"nodeType":"429","messageId":"430","endLine":34,"endColumn":43},{"ruleId":"427","severity":1,"message":"439","line":5,"column":10,"nodeType":"429","messageId":"430","endLine":5,"endColumn":22},{"ruleId":"427","severity":1,"message":"440","line":51,"column":13,"nodeType":"429","messageId":"430","endLine":51,"endColumn":23},{"ruleId":"427","severity":1,"message":"441","line":7,"column":52,"nodeType":"429","messageId":"430","endLine":7,"endColumn":57},{"ruleId":"427","severity":1,"message":"441","line":45,"column":37,"nodeType":"429","messageId":"430","endLine":45,"endColumn":42},{"ruleId":"427","severity":1,"message":"428","line":56,"column":23,"nodeType":"429","messageId":"430","endLine":56,"endColumn":58},{"ruleId":"427","severity":1,"message":"442","line":13,"column":10,"nodeType":"429","messageId":"430","endLine":13,"endColumn":33},{"ruleId":"427","severity":1,"message":"428","line":25,"column":17,"nodeType":"429","messageId":"430","endLine":25,"endColumn":43},{"ruleId":"423","severity":1,"message":"424","line":66,"column":7,"nodeType":"425","messageId":"426","endLine":66,"endColumn":30,"suggestions":"443"},{"ruleId":"423","severity":1,"message":"424","line":85,"column":7,"nodeType":"425","messageId":"426","endLine":85,"endColumn":30,"suggestions":"444"},{"ruleId":"445","severity":1,"message":"446","line":91,"column":39,"nodeType":"447","messageId":"448","endLine":91,"endColumn":42,"suggestions":"449"},{"ruleId":"450","severity":1,"message":"451","line":26,"column":8,"nodeType":"452","messageId":"453","endLine":26,"endColumn":42},{"ruleId":"450","severity":1,"message":"451","line":133,"column":8,"nodeType":"452","messageId":"453","endLine":133,"endColumn":29},{"ruleId":"427","severity":1,"message":"454","line":25,"column":5,"nodeType":"429","messageId":"430","endLine":25,"endColumn":30},{"ruleId":"427","severity":1,"message":"455","line":140,"column":12,"nodeType":"429","messageId":"430","endLine":140,"endColumn":36},{"ruleId":"427","severity":1,"message":"456","line":5,"column":3,"nodeType":"429","messageId":"430","endLine":5,"endColumn":22},{"ruleId":"427","severity":1,"message":"456","line":6,"column":3,"nodeType":"429","messageId":"430","endLine":6,"endColumn":22},{"ruleId":"427","severity":1,"message":"457","line":1,"column":10,"nodeType":"429","messageId":"430","endLine":1,"endColumn":21},{"ruleId":"427","severity":1,"message":"456","line":6,"column":3,"nodeType":"429","messageId":"430","endLine":6,"endColumn":22},"@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","@typescript-eslint/no-unused-vars","'params' is defined but never used.","Identifier","unusedVar","@typescript-eslint/ban-types","Don't use `Function` as a type. The `Function` type accepts any function-like value.\nIt provides no type safety when calling the function, which can be a common source of bugs.\nIt also accepts things like class declarations, which will throw at runtime as they will not be called with `new`.\nIf you are expecting the function to accept certain arguments, you should explicitly define the function shape.","bannedTypeMessage","'line' is defined but never used.","'unfilledCircle' is defined but never used.","'filledCircle' is defined but never used.","'filledRect' is defined but never used.","'pointEquals' is defined but never used.","'blobToCanvas' is defined but never used.","'colorIndex' is assigned a value but never used.","'state' is defined but never used.","'overlayCanvasController' is defined but never used.",["458"],["459"],"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["460","461"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","'backgroundColorId' is defined but never used.","'index' is defined but never used.","'canvasToWebGLCoordY' is defined but never used.","'CustomBrush' is defined but never used.",{"messageId":"462","fix":"463","desc":"464"},{"messageId":"462","fix":"465","desc":"464"},{"messageId":"466","fix":"467","desc":"468"},{"messageId":"469","fix":"470","desc":"471"},"suggestOptionalChain",{"range":"472","text":"473"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"474","text":"473"},"suggestUnknown",{"range":"475","text":"476"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"475","text":"477"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",[2192,2193],"?.",[2831,2832],[3012,3015],"unknown","never"]